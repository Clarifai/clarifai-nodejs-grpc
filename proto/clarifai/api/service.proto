

syntax = "proto3";

import "proto/clarifai/api/resources.proto";
import "proto/clarifai/api/status/status.proto";
import "proto/clarifai/api/utils/extensions.proto";
import "proto/clarifai/auth/scope/scope.proto";
import "proto/clarifai/auth/util/extension.proto";
import "proto/clarifai/api/status/status_code.proto";


import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";


package clarifai.api;

option go_package = "github.com/Clarifai/clarifai-go-grpc/proto/clarifai/api/api";
option java_multiple_files = true;
option java_package = "com.clarifai.grpc.api";
option objc_class_prefix = "CAIP";

/*
  Note: this is based on the google api format defined here. Please
  read this before contributing to this file and other *.proto files
  for the API.
  https://cloud.google.com/service-management/reference/rpc/google.api#google.api.HttpRule
 */



service V2 {





  ////////////////////////////////////////
  // Concept Relationships
  ////////////////////////////////////////


  // List concept relations between concepts in the platform.
  // MUST be above ListConcepts so that if concept_id is empty this will still match
  // /concepts/relations to list all the concept relations in the app.
  rpc ListConceptRelations (ListConceptRelationsRequest) returns (MultiConceptRelationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/relations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }



  // Post concept relations to create relations between concepts in the platform.
  rpc PostConceptRelations (PostConceptRelationsRequest) returns (MultiConceptRelationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post concept relations to create relations between concepts in the platform.
  rpc DeleteConceptRelations (DeleteConceptRelationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }




  ////////////////////////////////////////
  // Concepts
  ////////////////////////////////////////

  // List all the concepts with their positive and negative counts
  rpc GetConceptCounts (GetConceptCountsRequest) returns (MultiConceptCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/status"
      additional_bindings {
        get: "/v2/concepts/status"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific concept from an app.
  rpc GetConcept (GetConceptRequest) returns (SingleConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}"
      additional_bindings {
        get: "/v2/concepts/{concept_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the concepts.
  rpc ListConcepts (ListConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      additional_bindings {
        get: "/v2/concepts"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Search over the concepts to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc PostConceptsSearches (PostConceptsSearchesRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/searches"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // as it needs to know the concepts in your workflow's models.
  }

  // Add a concept to an app.
  rpc PostConcepts (PostConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      body: "*"
      additional_bindings {
        post: "/v2/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch one or more concepts.
  rpc PatchConcepts (PatchConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      body: "*"
      additional_bindings {
        patch: "/v2/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }














  ////////////////////////////////////////

  ////////////////////////////////////////
  // Concept Languages
  ////////////////////////////////////////

  // Get a specific concept from an app.
  rpc GetConceptLanguage (GetConceptLanguageRequest) returns (SingleConceptLanguageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages/{language}"
      additional_bindings {
        get: "/v2/concepts/{concept_id}/languages/{language}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List the concept in all the translated languages.
  rpc ListConceptLanguages (ListConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      additional_bindings {
        get: "/v2/concepts/{concept_id}/languages"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add a new tranlsation for this concept.
  rpc PostConceptLanguages (PostConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/{concept_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch the name for a given language names by passing in a list of concepts with the new names
  // for the languages.
  rpc PatchConceptLanguages (PatchConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      body: "*"
      additional_bindings {
        patch: "/v2/concepts/{concept_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }










  ////////////////////////////////////////
  // Knowledge Graph
  ////////////////////////////////////////

  // List all domain graphs.
  rpc ListKnowledgeGraphs (ListKnowledgeGraphsRequest) returns (MultiKnowledgeGraphResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs"
      additional_bindings {
        get: "/v2/concepts/knowledge_graphs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post domain graphs.
  rpc PostKnowledgeGraphs (PostKnowledgeGraphsRequest) returns (MultiKnowledgeGraphResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/knowledge_graphs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Start concept mapping jobs.
  rpc PostConceptMappingJobs (PostConceptMappingJobsRequest) returns (MultiConceptMappingJobResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings/jobs"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/mappings/jobs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }




  ////////////////////////////////////////
  // annotations
  ////////////////////////////////////////

  // Get a specific annotation from an app.
  rpc GetAnnotation (GetAnnotationRequest) returns (SingleAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}"
      additional_bindings {
        get: "/v2/inputs/{input_id}/annotations/{annotation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // List all the annotation.
  rpc ListAnnotations (ListAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      additional_bindings {
        get: "/v2/annotations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // Post annotations.
  rpc PostAnnotations (PostAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      body: "*"
      additional_bindings {
        post: "/v2/annotations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the models in your default workflow.
  }

  // Patch one or more annotations.
  rpc PatchAnnotations (PatchAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      body: "*"
      additional_bindings {
        patch: "/v2/annotations"
          body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the models in your default workflow.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // Patch annotations status by worker id and task id.
  rpc PatchAnnotationsStatus (PatchAnnotationsStatusRequest) returns (PatchAnnotationsStatusResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/task/{task_id}/annotations/status"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single annotation.
  rpc DeleteAnnotation (DeleteAnnotationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}"
      additional_bindings {
        delete: "/v2/inputs/{input_id}/annotations/{annotation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // for cleaning up some optimizations we have in DB layer for annotations.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete multiple annotations in one request.
  rpc DeleteAnnotations (DeleteAnnotationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/annotations"
      body: "*"
      additional_bindings {
        delete: "/v2/inputs/annotations"
          body: "*"
      }
      additional_bindings {
        delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
          body: "*"
      }
      additional_bindings {
        delete: "/v2/annotations"
          body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // for cleaning up some optimizations we have in DB layer for annotations.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Execute a search over annotation
  rpc PostAnnotationsSearches(PostAnnotationsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches"
      body: "*"
      additional_bindings {
        post: "/v2/annotations/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }


  ////////////////////////////////////////
  // Inputs
  ////////////////////////////////////////

  // Get input count per status.
  rpc GetInputCount (GetInputCountRequest) returns (SingleInputCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/status"
      additional_bindings {
        get: "/v2/inputs/status"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Streams all the inputs starting from oldest assets.
  rpc StreamInputs (StreamInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/stream"
      additional_bindings {
        get: "/v2/inputs/stream"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific input from an app.
  rpc GetInputSamples (GetInputSamplesRequest) returns (MultiInputAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/samples"
      additional_bindings {
        get: "/v2/tasks/{task_id}/inputs/samples"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific input from an app.
  rpc GetInput (GetInputRequest) returns (SingleInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}"
      additional_bindings {
        get: "/v2/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // List all the inputs.
  rpc ListInputs (ListInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      additional_bindings {
        get: "/v2/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Add an input (or set of inputs) to an app.
  // This call is synchronous if the PostInputsRequest contains exactly one image input. Otherwise,
  // it is asynchronous.
  rpc PostInputs (PostInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        post: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }




  // Patch one or more inputs.
  rpc PatchInputs (PatchInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        patch: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single input asynchronously.
  rpc DeleteInput (DeleteInputRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}"
      additional_bindings {
        delete: "/v2/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple inputs in one request.
  // This call is asynchronous.
  rpc DeleteInputs (DeleteInputsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        delete: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Execute a search over input
  rpc PostInputsSearches(PostInputsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/searches"
      body: "*"
      additional_bindings {
        post: "/v2/inputs/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Get predicted outputs from the model.
  rpc PostModelOutputs (PostModelOutputsRequest) returns (MultiOutputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/outputs"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/{version_id}/outputs"
        body: "*"
      }
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/outputs"
        body: "*"
      }
      additional_bindings {
        post: "/v2/models/{model_id}/outputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
  }









  ////////////////////////////////////////
  // Models
  ////////////////////////////////////////

  // Get a specific model type.
  rpc GetModelType (GetModelTypeRequest) returns (SingleModelTypeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/types/{model_type_id}"
      additional_bindings {
        get: "/v2/models/types/{model_type_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the supported open source licenses in the platform.
  rpc ListOpenSourceLicenses (ListOpenSourceLicensesRequest) returns (ListOpenSourceLicensesResponse) {
    option (google.api.http) = {
      get: "/v2/open_source_licenses"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }
    // List all the model types available in the platform.

    // List all the model types available in the platform.
  // This MUST be above ListModels so that the /models/types endpoint takes precedence.
  rpc ListModelTypes (ListModelTypesRequest) returns (MultiModelTypeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/types"
      additional_bindings {
        get: "/v2/models/types"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a specific model from an app.
  rpc GetModel (GetModelRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}"
      additional_bindings {
        get: "/v2/models/{model_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a the output info for a given model_id or model_id/version_id
  // combo.
  rpc GetModelOutputInfo (GetModelRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/output_info"
      additional_bindings {
        get: "/v2/models/{model_id}/output_info"
      }
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/output_info"
      }
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/output_info"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the models.
  rpc ListModels (ListModelsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      additional_bindings {
        get: "/v2/models"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }



  // Search over the models to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc PostModelsSearches (PostModelsSearchesRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/searches"
      body: "*"
      additional_bindings {
        post: "/v2/models/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Add a models to an app.
  // FIXME(zeiler): this should have been a plural response.
  rpc PostModels (PostModelsRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        post: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;  // Train is needed because it creates a new version.
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
  }

  // Patch one or more models.
  rpc PatchModels (PatchModelsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        patch: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
  }

  // Delete a single model.
  rpc DeleteModel (DeleteModelRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}"
      additional_bindings {
        delete: "/v2/models/{model_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple models in one request.
  rpc DeleteModels (DeleteModelsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        delete: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the inputs.
  rpc ListModelInputs (ListModelInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/inputs"
      additional_bindings {
        get: "/v2/models/{model_id}/inputs"
      }
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/inputs"
      }
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Model versions
  ////////////////////////////////////////

  // Get a specific model from an app.
  rpc GetModelVersion (GetModelVersionRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the models.
  rpc ListModelVersions (ListModelVersionsRequest) returns (MultiModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      additional_bindings {
        get: "/v2/models/{model_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }


  // NOTE: inconsistency: do we want this to return a SingleModelResponse?

  // Create a new model version to trigger training of the model.
  // FIXME(zeiler): this should have been a plural response.
  rpc PostModelVersions (PostModelVersionsRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  rpc PatchModelVersions (PatchModelVersionsRequest) returns (MultiModelVersionResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
  }

  // Delete a single model.
  rpc DeleteModelVersion (DeleteModelVersionRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}"
      additional_bindings {
        delete: "/v2/models/{model_id}/versions/{version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get the evaluation metrics for a model version.
  rpc GetModelVersionMetrics (GetModelVersionMetricsRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/metrics"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  // Run the evaluation metrics for a model version.
  rpc PostModelVersionMetrics (PostModelVersionMetricsRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/metrics"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/{version_id}/metrics"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }



  ////////////////////////////////////////

  ////////////////////////////////////////
  // Model References
  ////////////////////////////////////////

  // Lists model references tied to a particular model id.
  rpc ListModelReferences (ListModelReferencesRequest) returns (MultiModelReferenceResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/references"
      additional_bindings {
        get: "/v2/models/{model_id}/references"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }





  ////////////////////////////////////////

  ////////////////////////////////////////
  // Model Version Input Examples
  ////////////////////////////////////////

  rpc GetModelVersionInputExample (GetModelVersionInputExampleRequest) returns (SingleModelVersionInputExampleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/input_examples/{example_id}"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{model_version_id}/input_examples/{example_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  rpc ListModelVersionInputExamples (ListModelVersionInputExamplesRequest) returns (MultiModelVersionInputExampleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/input_examples"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{model_version_id}/input_examples"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }





  ////////////////////////////////////////

  ////////////////////////////////////////
  // Workflows
  ////////////////////////////////////////

  // Get a specific workflow from an app.
  rpc GetWorkflow (GetWorkflowRequest) returns (SingleWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the workflows.
  rpc ListWorkflows (ListWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      additional_bindings {
        get: "/v2/workflows"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }


  // Add a workflow to an app.
  rpc PostWorkflows (PostWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        post: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch one or more workflows.
  rpc PatchWorkflows (PatchWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        patch: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete a single workflow.
  rpc DeleteWorkflow (DeleteWorkflowRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}"
      additional_bindings {
        delete: "/v2/workflows/{workflow_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple workflows in one request.
  rpc DeleteWorkflows (DeleteWorkflowsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        delete: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Predict using a workflow.
  rpc PostWorkflowResults (PostWorkflowResultsRequest) returns (PostWorkflowResultsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_id}/results"
      body: "*"
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results"
        body: "*"
      }
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/results"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }


  // Compare embeddings distances using a workflow

  rpc PostWorkflowResultsSimilarity(PostWorkflowResultsSimilarityRequest) returns (PostWorkflowResultsSimilarityResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_id}/results/similarity"
      body: "*"
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results/similarity"
        body: "*"
      }
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/results/similarity"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Workflow Versions
  ////////////////////////////////////////

  // List workflow versions.
  rpc ListWorkflowVersions (ListWorkflowVersionsRequest) returns (MultiWorkflowVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get single workflow version.
  rpc GetWorkflowVersion (GetWorkflowVersionRequest) returns (SingleWorkflowVersionResponse) {
      option (google.api.http) = {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{workflow_version_id}"
        additional_bindings {
          get: "/v2/workflows/{workflow_id}/versions/{workflow_version_id}"
        }
      };
      option (clarifai.auth.util.cl_auth_type) = KeyAuth;
      option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete workflow versions.
  rpc DeleteWorkflowVersions (DeleteWorkflowVersionsRequest) returns (clarifai.api.status.BaseResponse) {
      option (google.api.http) = {
        delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
        body: "*"
        additional_bindings {
          delete: "/v2/workflows/{workflow_id}/versions"
          body: "*"
        }
      };
      option (clarifai.auth.util.cl_auth_type) = KeyAuth;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
  }

  // Patch workflow versions.
  rpc PatchWorkflowVersions (PatchWorkflowVersionsRequest) returns (MultiWorkflowVersionResponse) {
      option (google.api.http) = {
        patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
        body: "*"
        additional_bindings {
          patch: "/v2/workflows/{workflow_id}/versions"
          body: "*"
        }
      };
      option (clarifai.auth.util.cl_auth_type) = KeyAuth;
      option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
  }








  ////////////////////////////////////////
  // API Keys
  ////////////////////////////////////////

  // Get a specific key from an app.
  rpc GetKey (GetKeyRequest) returns (SingleKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/keys/{key_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List all the keys.
  rpc ListKeys (ListKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/keys"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List keys by app_id
  rpc ListAppKeys (ListAppKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/keys"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Search over the keys to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc DeleteKey (DeleteKeyRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/keys/{key_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Add a key to an app.
  rpc PostKeys (PostKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/keys"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Patch one or more keys.
  rpc PatchKeys (PatchKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/keys"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // API Keys in the public API -- request is itself Key authorized, and will tell
  // the user the scopes/access of the key/credential they're providing, as computed by
  // our authorizer:
  rpc MyScopes (MyScopesRequest) returns (MultiScopeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/myscopes"
      additional_bindings {
        get: "/v2/myscopes"
      }
      additional_bindings {
        get: "/v2/my_scopes"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // List all auth scopes available to me as a user.
  rpc ListScopes (ListScopesRequest) returns (MultiScopeDepsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/scopes"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }


  ////////////////////////////////////////
  // Apps
  ////////////////////////////////////////

  // Get a specific app from an app.
  rpc GetApp (GetAppRequest) returns (SingleAppResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the apps.
  rpc ListApps (ListAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps"
      additional_bindings {
        get: "/v2/apps"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Search over the apps to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc DeleteApp (DeleteAppRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Add a app to an app.
  // This needs to load the default workflow to make a copy, validating all the models in it, and
  // then writing the new workflow back to this new app.
  rpc PostApps (PostAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
  }

  // Patch one or more apps.
  rpc PatchApps (PatchAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Search over the applications to find one or more you're looking for.
  rpc PostAppsSearches (PostAppsSearchesRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/searches"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }















  ////////////////////////////////////////

  ////////////////////////////////////////
  // Password
  ////////////////////////////////////////

  // Validate new password in real-time for a user
  rpc PostValidatePassword (PostValidatePasswordRequest) returns (SinglePasswordValidationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/validate_password"
      body: "*"
      additional_bindings {
        post: "/v2/validate_password"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Get;
  }

























































  ////////////////////////////////////////
  // Searches
  ////////////////////////////////////////

  // Get a saved search.
  rpc GetSearch (GetSearchRequest) returns (SingleSearchResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      additional_bindings {
        get: "/v2/searches/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // List all saved searches.
  rpc ListSearches (ListSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      additional_bindings {
        get: "/v2/searches"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // Execute a new search and optionally save it.
  rpc PostSearches (PostSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      body: "*"
      additional_bindings {
        post: "/v2/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Execute a previously saved search.
  rpc PostSearchesByID (PostSearchesByIDRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      body: "*"
      additional_bindings {
        post: "/v2/searches/{id}"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // Evaluate the results of two search requests
  rpc PostAnnotationSearchMetrics(PostAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics"
      body: "*"
      additional_bindings {
        post: "/v2/annotations/searches/metrics"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // as it needs to know the concepts in your workflow's models.
  }

  // Get the evaluation results between two search requests
  rpc GetAnnotationSearchMetrics(GetAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}"
      additional_bindings {
        get: "/v2/annotations/searches/metrics/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }



  // List the evaluation results between two search requests
  rpc ListAnnotationSearchMetrics(ListAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics"
      additional_bindings {
        get: "/v2/annotations/searches/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  rpc DeleteAnnotationSearchMetrics (DeleteAnnotationSearchMetricsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}"
      additional_bindings {
        delete: "/v2/annotations/searches/metrics/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Delete;
  }

  // Delete a saved search.
  rpc DeleteSearch (DeleteSearchRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      additional_bindings {
        delete: "/v2/searches/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }






































  ////////////////////////////////////////

  ////////////////////////////////////////
  // Status Codes
  ////////////////////////////////////////

  // List all status codes.
  rpc ListStatusCodes (ListStatusCodesRequest) returns (MultiStatusCodeResponse) {
    option (google.api.http) = {
      get: "/v2/status_codes"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Get more details for a status code.
  rpc GetStatusCode (GetStatusCodeRequest) returns (SingleStatusCodeResponse) {
    option (google.api.http) = {
      get: "/v2/status_codes/{status_code_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }











  ////////////////////////////////////////
  // App Sharing
  ////////////////////////////////////////

  // owner list users who the app is shared with
  rpc ListCollaborators (ListCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
  }

  // add collaborators to an app.
  rpc PostCollaborators (PostCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
  }

  // Patch existing collaborators.
  rpc PatchCollaborators (PatchCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Delete;
  }

  // Delete existing collaborators.
  rpc DeleteCollaborators (DeleteCollaboratorsRequest) returns (clarifai.api.status.BaseResponse){
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add; // when deleting a collaborator, we also delete task workers associated to this collaborator
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Collaboration includes the app user are invitied to work on
  rpc ListCollaborations (ListCollaborationsRequest) returns (MultiCollaborationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/collaborations"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }







  ////////////////////////////////////////
  // App duplication
  ////////////////////////////////////////

  // start to duplicate an app which copies all the inputs, annotations, models, concepts etc. to a new app.
  // this is an async process, you should use ListAppDuplications or GetAppDuplication to check the status.
  rpc PostAppDuplications (PostAppDuplicationsRequest) returns (MultiAppDuplicationsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/duplications"
        body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // list all the app duplications user triggers
  rpc ListAppDuplications (ListAppDuplicationsRequest) returns (MultiAppDuplicationsResponse){
    option (google.api.http) = {
      get : "/v2/users/{user_app_id.user_id}/duplications"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // get the app duplication status
  rpc GetAppDuplication (GetAppDuplicationRequest) returns (SingleAppDuplicationResponse) {
    option (google.api.http) = {
      get : "/v2/users/{user_app_id.user_id}/duplications/{app_duplication_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }


  ////////////////////////////////////////
  // Tasks
  ////////////////////////////////////////

  // Add tasks to an app.
  rpc PostTasks (PostTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        post: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional, needed for add_task_annotations.go when saved search uses visual search
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add; // needed for add_task_annotations.go
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get; // needed for add_task_annotations.go
  }

  // Task annotation count
  rpc GetTaskAnnotationCount (GetTaskCountRequest) returns (SingleTaskCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/annotations/count"
      additional_bindings {
        get: "/v2/tasks/{task_id}/annotations/count"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Task Input count
  rpc GetTaskInputCount (GetTaskCountRequest) returns (SingleTaskCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/count"
      additional_bindings {
        get: "/v2/tasks/{task_id}/inputs/count"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Get a specific task from an app.
  rpc GetTask (GetTaskRequest) returns (SingleTaskResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}"
      additional_bindings {
        get: "/v2/tasks/{task_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // List tasks from an app.
  rpc ListTasks (ListTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      additional_bindings {
        get: "/v2/tasks"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // Patch one or more tasks.
  rpc PatchTasks (PatchTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        patch: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional, needed for add_task_annotations.go when saved search uses visual search
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add; // needed for add_task_annotations.go
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get; // needed for add_task_annotations.go
  }

  // Delete multiple tasks in one request.
  rpc DeleteTasks (DeleteTasksRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        delete: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Delete;
  }









  ////////////////////////////////////////
  // Collectors
  ////////////////////////////////////////

  // Add a list of Collectors to an app.
  // In the handler of this endpoint we also check for all the scopes of the  POST /inputs
  // endpoint.
  // Those current scopes are listed here as a hard requirement.
  // They are needed when adding the collectors just so we now that you have permission with
  // that key at least to do the writing to this app with POST /inputs.
  rpc PostCollectors (PostCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        post: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get a specific collector from an app.
  rpc GetCollector (GetCollectorRequest) returns (SingleCollectorResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors/{collector_id}"
      additional_bindings {
        get: "/v2/collectors/{collector_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // List all the collectors.
  rpc ListCollectors (ListCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      additional_bindings {
        get: "/v2/collectors"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // Patch one or more collectors.
  rpc PatchCollectors (PatchCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        patch: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }



  // Delete multiple collectors in one request.
  // This call is asynchronous. Use DeleteCollector if you want a synchronous version.
  rpc DeleteCollectors (DeleteCollectorsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        delete: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }


  ////////////////////////////////////////////////////////////////////////////////
  // Stats Collection Endpoints.
  ////////////////////////////////////////////////////////////////////////////////

  rpc PostStatValues (PostStatValuesRequest) returns (MultiStatValueResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values"
      body: "*"
      additional_bindings {
        post: "/v2/stats/values"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }



  rpc PostStatValuesAggregate (PostStatValuesAggregateRequest) returns (MultiStatValueAggregateResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values/aggregate"
      body: "*"
      additional_bindings {
        post: "/v2/stats/values/aggregate"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }










  ////////////////////////////////////////
  // Trending Metrics
  ////////////////////////////////////////

  // Increase the view metric for a detail view
  rpc PostTrendingMetricsView (PostTrendingMetricsViewRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/trending_metrics/views/{view_type}/{object_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // List the view metrics for a detail view
  rpc ListTrendingMetricsViews (ListTrendingMetricsViewsRequest) returns (MultiTrendingMetricsViewResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/trending_metrics/views/{view_type}"
      additional_bindings {
        get: "/v2/trending_metrics/views/{view_type}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }


}


// Split the results into pages.
message Pagination {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults to 128.
  uint32 per_page = 2;
}



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/annotation.proto
////////////////////////////////////////////////////////////////////////////////
message GetAnnotationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string annotation_id = 2;
  string input_id = 3;
}

message ListAnnotationsRequest {
  reserved 4;

  clarifai.api.UserAppIDSet user_app_id = 1;

  // List annotations for these IDs
  repeated string ids = 2;

  // List annotations for these Input IDs
  // Note that 'ids' are optional but if the are provided the number and order in
  // 'ids' and 'input_ids' should match
  // If you do not specify 'ids' all the annotations for 'input_ids' are returned
  // If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
  repeated string input_ids = 3;

  // Only return the annotations that has one of these user IDs, effectively operating as an
  // OR among them to filter down the results.
  // If model_version_ids are also provided these user_ids are OR'd with them as well since
  // annotations are either provided by users or model versions and we want the union of any
  // provided user or model version annotations in the results of ListAnnotations request.
  // If no user_ids are provided then annotations from all users are returned.
  repeated string user_ids = 9;

  // Only return the annotations that has one of these model version IDs, effectively operating as an
  // OR among them to filter down the results.
  // If user_ids are also provided these model_versions_ids are OR'd with them as well since
  // annotations are either provided by users or model versions and we want the union of any
  // provided user or model version annotations in the results of ListAnnotations request.
  // If no model_version_ids are provided then annotations from all model versions are returned.
  repeated string model_version_ids = 10;

  // Set status to filter by a list of statuses
  // If not statuses are provided then annotations with any status will be returned.
  repeated clarifai.api.status.Status statuses = 5;

  // Set this flag to list both trusted and not trusted annotations
  // by default it's listing only trusted annotations
  bool list_all_annotations = 6;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 7;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 8;
  // Flag to filter annotations by task_id
  string task_id = 11;
}

message PostAnnotationsRequest {

  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Annotation annotations = 2;
}

message PatchAnnotationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Annotation annotations = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message PatchAnnotationsStatusRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Annotation Status code
  clarifai.api.status.StatusCode status_code = 2;
  repeated string user_ids = 3;
  string task_id = 4;
  // 'overwrite' is supported
  string action = 5;

}

message PatchAnnotationsStatusResponse {
  clarifai.api.status.Status status = 1;
  repeated string user_ids = 2;
  uint32 updated_count = 3;
}

message DeleteAnnotationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string input_id = 2;

  string annotation_id = 3;
}

// Request to delete several things by the list of ids.
message DeleteAnnotationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Delete annotations with IDs
  repeated string ids = 2;

  // Delete annotations for these Input IDs
  // Note that 'ids' are optional but if the are provided the number and order in
  // 'ids' and 'input_ids' should match
  // If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
  // However you need to specify at least one value for 'input_ids'
  // i.e. this API does not support deleting all annotations
  repeated string input_ids = 3;
}

message SingleAnnotationResponse {
  clarifai.api.status.Status status = 1;
  Annotation annotation = 2;
}

message MultiAnnotationResponse {
  clarifai.api.status.Status status = 1;

  repeated Annotation annotations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}


////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/app.proto
////////////////////////////////////////////////////////////////////////////////
message GetAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message ListAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Sorting opitons:
   // Whether to sort in ascending order. If false, will order in descending order.
   bool sort_ascending = 5;
   oneof sort_by {
    // Whether to order by the name
    bool sort_by_name = 6;
    // Whether to order by the modified_at time.
    // If neither sort option is set to true, will sort by modified_at.
    bool sort_by_modified_at = 7;
   }

  // Filtering options:
  // Query various text fields that can contain the words in the query string
  string query = 8;
  // Filter by the name of the app. This supports wilcard queries like "gen*" to match "general" as an example.
  // Deprecated in favor of query
  string name = 4 [deprecated = true];
  // If true, we only return workflows that are handpicked by clarifai staff
  bool featured_only = 9;
}

message PostAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated App apps = 2;
}

message DeleteAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message PatchAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated App apps = 2;

  // The action to perform on the patched App objects except App.Metadata
  // For now only action 'overwrite' is supported
  string action = 3;

  // The action to perform on the patched App.Metadata
  clarifai.api.PatchAction metadata_action = 4;

  // If set, the app will be automatically reindexed upon change of its base workflow.
  bool reindex = 5;
}

// Search over the available applications.
message PostAppsSearchesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  AppQuery app_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

message SingleAppResponse {
  clarifai.api.status.Status status = 1;
  App app = 2;
}

message MultiAppResponse {
  clarifai.api.status.Status status = 1;
  repeated App apps = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}




////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/app_sharing.proto
////////////////////////////////////////////////////////////////////////////////
message ListCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Set this flag to list both deleted and not deleted collaborators
  // by default it's listing only not deleted collaborators
  bool list_all_collaborators = 2;
}

message PostCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collaborator collaborators = 2;
}

message PatchCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collaborator collaborators = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

message DeleteCollaboratorsRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string collaborator_ids = 2;
  repeated string user_emails = 3;
}

message MultiCollaboratorsResponse {
  clarifai.api.status.Status status = 1;
  repeated Collaborator collaborators = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message ListCollaborationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message MultiCollaborationsResponse {
  clarifai.api.status.Status status = 1;
  repeated Collaboration collaborations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}













































////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/cluster.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/code.proto
////////////////////////////////////////////////////////////////////////////////
message GetStatusCodeRequest {
  string status_code_id = 1;
}

message ListStatusCodesRequest {
}

message SingleStatusCodeResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

message MultiStatusCodeResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.status.Status statuses = 2;
}










////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/color.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/common.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/concept.proto
////////////////////////////////////////////////////////////////////////////////
message GetConceptRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept's id.
  string concept_id = 2;
}

message ListConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message PostConceptsSearchesRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  ConceptQuery concept_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

message PostConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concepts to add.
  repeated Concept concepts = 2;
}

message PatchConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concepts to patch.
  repeated Concept concepts = 2;

  // The action to perform on the patched objects
  // For now ony action 'overwrite' is supported
  string action = 3;
}

message GetConceptCountsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message SingleConceptResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept.
  Concept concept = 2;
}

message MultiConceptResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concepts.
  repeated Concept concepts = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiConceptCountResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept counts.
  repeated ConceptCount concept_counts = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}




////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/concept_graph.proto
////////////////////////////////////////////////////////////////////////////////
//////////////////////
// Responses
//////////////////////
// Requests
//////////////////////
// GET all relations such that the concept_id refers to the subject of the relation
message ListConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The subject concept id in your app to get all the relationships for.
  // Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
  //
  // When listing all the relations it will only return one direction of the relationship
  // with the predicate acting on the subject and not the inverse like is done when providing a
  // concept_id so that we can return a reliable page size always.
  //
  // When providing a concept_id, if a hyponym is present in the DB such as:
  // 'honey' (subject), 'hyponym' (predict for "is a kind of"), 'food' (object)
  // then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
  // object.
  // But you can also list the concept relations for 'food' and it will return the same hyponym
  // relationship with 'honey' as subject and 'food' as predicate.
  // Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
  // when listing the relations.
  string concept_id = 2;
  // This is part of the url so we can extend to multiple link types in the future.
  // Valid predicates are:
  // 'hypernyms'
  // 'hyponyms'
  string predicate = 3;
  // If knowledge_graph_id is provided then just list relations from that knowledge graph.
  // If not provided then list relations from all knowledge graphs including the global one for this
  // app one (ie. knowledge_graph "") and any specific ones in the app.
  string knowledge_graph_id = 4;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 5;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 6;
}

// POST new concept relations
message PostConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The subject concept id you're going to add relations for.
  string concept_id = 2;
  // The relationships you're going to add.
  repeated ConceptRelation concept_relations = 3;
}

// DELETE concept relations
message DeleteConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept to delete relationship for.
  string concept_id = 2;
  // The concept relationship ids to delete.
  repeated string ids = 3;
}

// GET all knowledge graphs
message ListKnowledgeGraphsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// POST new knowledge graphs
message PostKnowledgeGraphsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated KnowledgeGraph knowledge_graphs = 2;
}



// Start concept mapping jobs
message PostConceptMappingJobsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept mapping jobs that are being started
  repeated ConceptMappingJob concept_mapping_jobs = 2;
}


message MultiConceptRelationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept relations.
  repeated ConceptRelation concept_relations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}


message MultiKnowledgeGraphResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned knowledge graphs.
  repeated KnowledgeGraph knowledge_graphs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}




message MultiConceptMappingJobResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The ids of the concept mapping jobs underway.
  repeated string ids = 2;
}




////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/concept_language.proto
////////////////////////////////////////////////////////////////////////////////
// GET single concept language for the given concept.
message GetConceptLanguageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  // This is the language identifier.
  string language = 3;
}

// List multiple concept languages for the given concept.
message ListConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// PATCH multiple concept languages for the given concept.
message PatchConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  repeated ConceptLanguage concept_languages = 3;
  // The action to perform with the objects in the PATCH.
  string action = 4;
}



// // DELETE multiple concept languages for the given concept.
// message DeleteConceptLanguageRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   string concept_id = 2;
//   // The language code to delete.
//   string language = 3;
// }

// // DELETE multiple concept languages for the given concept.
// message DeleteConceptLanguagesRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   string concept_id = 2;
//   // The language code(s) to delete.
//   string ids = 3;
//   bool delete_all = 4;
// }

// POST multiple concept languages for the given concept.
message PostConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  repeated ConceptLanguage concept_languages = 3;
}

message SingleConceptLanguageResponse {
  clarifai.api.status.Status status = 1;
  ConceptLanguage concept_language = 2;
}

message MultiConceptLanguageResponse {
  clarifai.api.status.Status status = 1;
  repeated ConceptLanguage concept_languages = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

































////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/image.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/input.proto
////////////////////////////////////////////////////////////////////////////////
message GetInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}

message GetInputSamplesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
  // URL param. If zero ids provided, returns for all task labelers
  repeated string user_ids = 3;
}

message ListInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Set status to filter by status
  clarifai.api.status.Status status = 5;

  repeated string ids = 4;
}

message StreamInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;
  string last_id = 3;


  bool descending = 4;
}

message PostInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Input inputs = 2;
}





message PatchInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Input inputs = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message DeleteInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteInputsRequest {
  reserved 3;

  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

message SingleInputResponse {
  clarifai.api.status.Status status = 1;
  Input input = 2;
}

message MultiInputResponse {

  clarifai.api.status.Status status = 1;
  repeated Input inputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiInputAnnotationResponse {

  clarifai.api.status.Status status = 1;
  repeated Hit hits = 3 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message SingleInputCountResponse {
  clarifai.api.status.Status status = 1;

  // NOTE: inconsistency: not named after the object name.
  InputCount counts = 2;
}

message GetInputCountRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}










////////////////////////////////////////////////////
// Model prediction related stuff needs inputs and produces outputs.
////////////////////////////////////////////////////
// Model prediction.
message PostModelOutputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  repeated Input inputs = 4;
  // This allows you to specify config options for the model such as
  // the language which appear's in the model's output_info.
  Model model = 5;
}

// Listing the inputs that went into training this model.
message ListModelInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;
}




////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/key.proto
////////////////////////////////////////////////////////////////////////////////
message GetKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string key_id = 2;
}

message ListKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message ListAppKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message PostKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Key keys = 2;
}

message DeleteKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string key_id = 2;
}

message PatchKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Key keys = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

message SingleKeyResponse {
  clarifai.api.status.Status status = 1;
  Key key = 2;
}

message MultiKeyResponse {
  clarifai.api.status.Status status = 1;
  repeated Key keys = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}















////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/model.proto
////////////////////////////////////////////////////////////////////////////////
message GetModelRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  // This is included so that we can re-use this request for multiple
  // rpcs with and without the version_id.
  string version_id = 3;
  string language = 4;
  bool trained_before = 5;
}

message ListModelsRequest {
  reserved 4;
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 10;
  oneof sort_by {
    // Whether to order by the name
    bool sort_by_name = 11;
    // Whether to order by the number of training inputs
    bool sort_by_num_inputs = 12;
    // Whether to order by the modified_at time of the latest model version.
    // If neither sort option is set to true, will sort by modified_at.
    bool sort_by_modified_at = 13;
  }

  // Filtering options:
  // // Query various text fields that can contain the words in the query string
  string query = 14;
  // Filter by the name of the model. This supports wilcard queries like "gen*" to match "general" as an example.
  // Deprecated in favor of query
  string name = 5 [deprecated = true];
  // Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
  // supported.
  string model_type_id = 6;
  // If true, we only return models that have the status MODEL_TRAINED, which includes non-trainable model types.
  bool trained_only = 7;
  // The list of input fields to the model.
  // For example, you can specify 'image', which will return models that make inferences on images like visual-classifier models.
  repeated string input_fields = 8;
  // The list of output fields to the model.
  // For example, you can specify 'regions[...].data.concepts', which will return visual-detector models.
  repeated string output_fields = 9;
  // Filter by the license of the model version
  string license = 15;
  // If true, we only return models that are handpicked by clarifai staff
  bool featured_only = 16;
}

message PostModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // NOTE: inconsistent since "model" is not plural, please use "models" below.
  // Previously you could only create one model at a time.
  // We still support this but you should pass it as models=[model] so
  // that this endpoint is consistent with the rest of our API.
  Model model = 2 [deprecated = true];
  // This allows you to create one or more model by posting it to the API.
  repeated Model models = 3;
}

message PatchModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Model models = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message DeleteModelRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// Search over the available models.
message PostModelsSearchesRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  ModelQuery model_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

message SingleModelResponse {
  clarifai.api.status.Status status = 1;
  Model model = 2;
}

message MultiModelResponse {
  clarifai.api.status.Status status = 1;
  repeated Model models = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}




////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/model_version.proto
////////////////////////////////////////////////////////////////////////////////
message PatchModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersion model_versions = 3;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 4;
}

// NOTE: this is same as GetModelRequest but backend doesn't support sharing same
// request for different endpoints currently.
message GetModelVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
}

message ListModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
  // To list only the model versions that have these concept ids present in them.
  repeated string concept_ids = 5;
}

message DeleteModelVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 3;
  string version_id = 4;
}

message SingleModelVersionResponse {
  clarifai.api.status.Status status = 1;
  ModelVersion model_version = 2;
}

message MultiModelVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated ModelVersion model_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Create (train) a new model version.
message PostModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;

  // This lets you post an existing model version rather than training a new one.
  // For internal Clarifai use only to start.
  repeated ModelVersion model_versions = 3;

  // Use this to filter inputs that are used in training
  clarifai.api.Search search = 4 [deprecated = true];
  //train_search is used to specify what data to train on.
  clarifai.api.Search train_search = 5;
  //test_search is used to specify what data to test on.
  clarifai.api.Search test_search = 6;
  // whether to evaluate the transfer trained model after training
  bool evaluate_after_training = 7;
  // Description about this training run
  string description = 8;
}



// Evaluate this model version.
message PostModelVersionMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  uint32 max_examples = 4;

  // Use this to filter inputs that are used in evaluation
  clarifai.api.Search test_search = 5;
}

// Get the already computed evaluation metrics for this model
// version.
message GetModelVersionMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;

  // Any of the fields you wish to return from multiclass_metrics
  FieldsValue fields = 4;
}





// TODO: should we just move to this and get rid of above.
// // Request to delete several things by the list of ids.
// message DeleteModelVersionsRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   repeated string ids = 2;
//   bool delete_all = 3;
// }

////////////////////////////////////////////////////////////////////////////////

message GetModelTypeRequest {
  // use and app combo. Not really used for this endpoint at this time so may go away in future.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The specific ModelType.Id you want to retrieve.
  string model_type_id = 2;
}

message ListModelTypesRequest {
  // use and app combo. Not really used for this endpoint at this time so may go away in future.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message ListOpenSourceLicensesRequest {}

message ListOpenSourceLicensesResponse {
  clarifai.api.status.Status status = 1;
  repeated string licenses = 2;
}

message SingleModelTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // The retrieved ModelType object. .
  ModelType model_type = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiModelTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // List of ModelType objects.
  repeated ModelType model_types = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}




////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses for Model Version Input Examples
////////////////////////////////////////////////////////////////////////////////
message GetModelVersionInputExampleRequest {
  // authorization field  (contains app/user id info)
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of model the example belongs to
  string model_id = 2;
  // specific version the example belongs to
  string model_version_id = 3;
  // Id of example to fetch
  string example_id = 4;
}

message ListModelVersionInputExamplesRequest {
  // authorization field  (contains app/user id info)
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of model the example belongs to
  string model_id = 2;
  // specific version the example belongs to
  string model_version_id = 3;
  // Optional, defaults to 1.
  uint32 page = 4;
  // Optional, defaults to 128 references per page.
  uint32 per_page = 5;
}



message SingleModelVersionInputExampleResponse {
  // status of response
  clarifai.api.status.Status status = 1;
  // model input example message
  ModelVersionInputExample model_version_input_example = 2;
}

message MultiModelVersionInputExampleResponse {
  // status of response
  clarifai.api.status.Status status = 1;
  // model input example messages
  repeated ModelVersionInputExample model_version_input_examples = 2;
}



////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses for Model References
////////////////////////////////////////////////////////////////////////////////

message ListModelReferencesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;
  // Optional, defaults to 1.
  uint32 page = 3;
  // Optional, defaults to 128 references per page.
  uint32 per_page = 4;
}



message MultiModelReferenceResponse {
  clarifai.api.status.Status status = 1;
  repeated ModelReference model_references = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/output.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////
// Outputs related requests
////////////////////////////////////////////////////
message MultiOutputResponse {
  clarifai.api.status.Status status = 1;
  repeated Output outputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}




////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/scope.proto
////////////////////////////////////////////////////////////////////////////////
message ListScopesRequest {
  // If "personal_access_token" include scopes and endpoints available to personal access tokens.
  // If "api_key" include scopes and endpoints available to app-specific keys. (default)
  string key_type = 1;

  // For all user specific information we include user_app_id to get the user_id in a consistent way
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message MyScopesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message MultiScopeDepsResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // scopes is a list of low-level scopes and their dependencies.
  repeated ScopeDeps scope_deps = 2;
  // endpoint_scopes is a listof all the publicly available endponts which can be
  // used as scopes as well. A call to each of those endpoint depends on a subset
  // of the above "scopes"
  repeated EndpointDeps endpoint_deps = 3;
}

message MultiScopeResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // This is a list of the scopes that your key has.
  repeated string scopes = 2;
  // The app that the key has access to.
  App app = 3;
  // This is a list of endpoint permissions that your key has.
  repeated string endpoints = 4;
}




////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/search.proto
////////////////////////////////////////////////////////////////////////////////
message GetSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

message ListSearchesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message PostSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The query; this specifies how the data to be searched
  // this will be replaced by "Searches"
  Query query = 2 [deprecated=true];

  // The searched to be executed or saved
  // Eventually the request level fields will be deprecated in favor of this object
  repeated Search searches = 3;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 4;
}

// PostSearchesByIDRequest performs returns results of a saved search given its ID
message PostSearchesByIDRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // ID for saves search to be executed
  string id = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

message DeleteSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}


// Execute a new annotation search and optionally save it
// annotation search over annotations using rank and filter proto
message PostAnnotationsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searched to be executed or saved
  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

message DeleteAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// Execute a new input search and optionally save it
message PostInputsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searched to be executed or saved
  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

// SingleSearchResponse returns saved search in response to GetSearchRequest
message SingleSearchResponse {
  // Status of whether the search was successful.
  clarifai.api.status.Status status = 1;
  Search search = 5;
}

message MultiSearchResponse {
  // Status of whether the search was successful.
  clarifai.api.status.Status status = 1;

  // A unique id which uniquely identifies a search
  string id = 2;

  // The list of search result Hits.
  repeated Hit hits = 3 [(clarifai.api.utils.cl_show_if_empty) = true];

  // The original query provided in the request.
  Query query = 4;

  // The original Searches provided in the request.
  repeated Search searches = 5;
}

message PostAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // A unique customer facing id to identify this eval request
  string id = 2;

  // The ground truth we are evaluating against
  clarifai.api.Search ground_truth = 3;

  // The set we are evaluating
  clarifai.api.Search search_to_eval = 4;

  // List of concepts to evaluate are expected to be in data.concepts
  // If nil, then all app concepts are used
  Data data = 5;

  // The type of evaluation to use
  EvaluationType evaluation_type = 6;
}

message GetAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Unique custom facing id that identifies the eval to get
  string id = 2;
}

message ListAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message MultiAnnotationSearchMetricsResponse {
  // Status of the request
  clarifai.api.status.Status status = 1;
  repeated AnnotationSearchMetrics annotation_search_metrics = 2;
}




























































message PostValidatePasswordRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // password to be validated
  Password password = 2;
}

message SinglePasswordValidationResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  PasswordViolations password_violations = 2;
}
































enum OrganizationInvitationStatus {
  NOT_SET = 0;
  PENDING = 1;
  ACCEPTED = 2;
  CANCELLED = 3;
  DECLINED = 4;
  EXPIRED = 5;
}


































































////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/workflow.proto
////////////////////////////////////////////////////////////////////////////////
message GetWorkflowRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Workflow ID to retrieve
  // If no ID is specified we return default workflow of the application
  // If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  string workflow_id = 2;

  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 3;
}

message ListWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

    // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 5;
  oneof sort_by {
    // Whether to order by the name
    bool sort_by_id = 6;
    // Whether to order by the modified_at time.
    // If neither sort option is set to true, will sort by modified_at.
    bool sort_by_modified_at = 7;
  }

  // Query various text fields that can contain the words in the query string.
  string query = 8;
  // Filter by the id of the workflow. This supports wilcard queries like "gen*" to match "general" as an example.
  // Deprecated in favor of query
  string id = 4 [deprecated = true];
  // If true, we only return workflows that are handpicked by clarifai staff
  bool featured_only = 9;
}


message PostWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Workflow workflows = 2;
}

message PatchWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Workflow workflows = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message DeleteWorkflowRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

message SingleWorkflowResponse {
  clarifai.api.status.Status status = 1;
  Workflow workflow = 2;
}



message MultiWorkflowResponse {
  clarifai.api.status.Status status = 1;
  repeated Workflow workflows = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message PostWorkflowResultsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Workflow ID to retrieve
  // If no ID is specified we return default workflow of the application
  // If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  string workflow_id = 2;

  // Workflow version ID to retrieve
  // If no ID is specified, latest workflow version is used
  string version_id = 7;

  repeated Input inputs = 3;
  // FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
  // to be within models. This is not consistent with setting this on the request for post model
  // outputs where it is inside a model object. To make this consistent we would send in the
  // workflow object so that each model can have it's own output config. If nobody is setting
  // this OutputConfig it would probably be easier to just remove it for now to keep things simpler
  // and then it's more consistent we just don't support the OutputConfig on workflows.
  OutputConfig output_config = 4;

  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 5;

  // A workflow state to be maintained across PostWorkflowResults requests/responses.
  // If it is not sent in the initial request with workflow_state.id = "init" then no
  // state will be saved or returned in PostWorkflowResultsResponse.
  WorkflowState workflow_state = 6;
}

message PostWorkflowResultsResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // The workflow that was used in predictions with PostWorkflowResults
  Workflow workflow = 2;
  // The resulting predictions of all models in the workflow.
  repeated WorkflowResult results = 3;
  // A workflow state to be maintained across PostWorkflowResults requests/responses.
  // This WorkflowState should be passed in to subsequent PostWorkflowResults calls
  // if you want to keep track of state across requests.
  // If no WorkflowState was initialized in a request then no WorkflowState will be returned in this
  // response.
  WorkflowState workflow_state = 4;
}

message PostWorkflowResultsSimilarityRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
  // Workflow version ID to retrieve
  // If no ID is specified, latest workflow version is used
  string version_id = 7;
  // The specific model version whose outputs we are comparing
  string model_version_id = 3;
  // Each probe is compared against every pool input
  repeated Input probe_inputs = 4;
  // Each pool input is compared against ever probe input
  repeated Input pool_inputs = 5;
  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 6;
}

message PostWorkflowResultsSimilarityResponse {
  clarifai.api.status.Status status = 1;
  repeated WorkflowResultsSimilarity results = 2;
}


////////////////////////////////////////////////////////////////////////////////
// Workflow Versions
////////////////////////////////////////////////////////////////////////////////

message ListWorkflowVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List versions for the workflow identified by this id
  string workflow_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

message GetWorkflowVersionRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested version.
    string workflow_id = 2;
    // Get the identified by this id
    string workflow_version_id = 3;
}

message DeleteWorkflowVersionsRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested versions to delete.
    string workflow_id = 2;
    // Delete the versions identified by these ids
    repeated string workflow_version_ids = 3;
}

message PatchWorkflowVersionsRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested versions to patch.
    string workflow_id = 2;
    // Patch these versions.
    repeated WorkflowVersion workflow_versions = 3;
    // The action to perform on the patched objects
    // For now actions 'merge', 'overwrite', and 'remove' are supported
    string action = 4;
}

message MultiWorkflowVersionResponse {
    clarifai.api.status.Status status = 1;
    repeated WorkflowVersion workflow_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message SingleWorkflowVersionResponse {
    clarifai.api.status.Status status = 1;
    WorkflowVersion workflow_version = 2;
}











////////////////////////////////////////////////////////////////////////////////
// App Duplication
////////////////////////////////////////////////////////////////////////////////

//Request to start a app duplication process
message PostAppDuplicationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated AppDuplication app_duplications = 2;
}

//Request to check app duplication status
message GetAppDuplicationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  //The app duplication id
  string app_duplication_id = 2;
}

//Request to list all the app duplication that user triggered.
message ListAppDuplicationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message MultiAppDuplicationsResponse {
  clarifai.api.status.Status status = 1;
  repeated AppDuplication app_duplications = 2;
}



message SingleAppDuplicationResponse {
  clarifai.api.status.Status status = 1;
  AppDuplication app_duplication = 2;
}


////////////////////////////////////////////////////////////////////////////////
// Tasks
////////////////////////////////////////////////////////////////////////////////

// Request to create Tasks.
message PostTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Task tasks = 2;
}

// Request to get one task.
message GetTaskRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
}

// Request to list multiple tasks.
message ListTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
  // Get tasks that have ANY user from this list assigned as worker.
  repeated string worker_user_ids = 4;
  // Get tasks that have ANY user from this list assigned as reviewer.
  repeated string review_user_ids = 5;
  // Get label order tasks as well
  bool including_label_order_tasks = 6;
}

// Request to patch a list of tasks.
message PatchTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Task tasks = 2;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete a list of tasks.
message DeleteTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// Response with multiple Tasks.
message MultiTaskResponse {
  clarifai.api.status.Status status = 1;
  repeated Task tasks = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Response with a single Task.
message SingleTaskResponse {
  clarifai.api.status.Status status = 1;
  Task task = 2;
}

// GetTaskCountRequest can be used for fetching -
// 1. Task annotation count per user, per status
// 1. Task input (anchor annotations) count per user, per status
message GetTaskCountRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;

  // task_id for which count per user per status is needed
  string task_id = 2;

  // for given task_id, user_ids to filter on (optional)
  repeated string user_ids= 3;
}



// SingleTaskCountResponse represent counts of annotations or inputs(anchor annotations) for labelers in given task
message SingleTaskCountResponse {
  clarifai.api.status.Status status = 1;
  string app_id = 2;
  string task_id = 3;
  repeated TaskStatusCountPerUser counts = 4;
}










////////////////////////////////////////////////////////////////////////////////
// Collectors
////////////////////////////////////////////////////////////////////////////////

// Request to create Collectors.
message PostCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collector collectors = 2;
}

message PatchCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Collector collectors = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete several things by the list of ids.
message DeleteCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// Request to GET a single Collector.
message GetCollectorRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  //The collecgtor id
  string collector_id = 2;
}

// Request to GET all the Collectors.
message ListCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Response with multiple Collectors.
message MultiCollectorResponse {
  clarifai.api.status.Status status = 1;
  repeated Collector collectors = 2;
}

// Response with a single Collector.
message SingleCollectorResponse {
  clarifai.api.status.Status status = 1;
  Collector collector = 2;
}





////////////////////////////////////////////////////////////////////////////////
// Stats Collection Endpoints.
////////////////////////////////////////////////////////////////////////////////
message PostStatValuesRequest {
  // The user and app information for the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The stats to post, can post more than one at a time.
  repeated StatValue stat_values = 2;
}

message MultiStatValueResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned stats values.
  repeated StatValue stat_values = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}



message PostStatValuesAggregateRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Query to retrieve aggregate values.
  repeated StatValueAggregateQuery stat_value_aggregate_queries = 2;
}

message MultiStatValueAggregateResponse {
  // The response status.
  clarifai.api.status.Status status = 1;

  // The aggregate results for each query passedin.
  repeated StatValueAggregateResult stat_value_aggregate_results = 2;
}












////////////////////////////////////////
// Trending Metrics
////////////////////////////////////////

message PostTrendingMetricsViewRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // For now view types 'apps', 'workflows', and 'models' are supported.
  string view_type = 2;
  // ID of the views object.
  string object_id = 3;
}

message ListTrendingMetricsViewsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // For now view types 'apps', 'workflows', and 'models' are supported.
  string view_type = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

message MultiTrendingMetricsViewResponse {
  clarifai.api.status.Status status = 1;
  repeated TrendingMetric metrics = 2;
}





