

syntax = "proto3";

import "proto/clarifai/api/resources.proto";
import "proto/clarifai/api/status/status.proto";
import "proto/clarifai/api/utils/extensions.proto";
import "proto/clarifai/auth/scope/scope.proto";
import "proto/clarifai/auth/util/extension.proto";
import "proto/clarifai/api/status/status_code.proto";


import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";


package clarifai.api;

option go_package = "github.com/Clarifai/clarifai-go-grpc/proto/clarifai/api";
option java_multiple_files = true;
option java_package = "com.clarifai.grpc.api";
option objc_class_prefix = "CAIP";

/*
  Note: this is based on the google api format defined here. Please
  read this before contributing to this file and other *.proto files
  for the API.
  https://cloud.google.com/service-management/reference/rpc/google.api#google.api.HttpRule

  For the cl_depending_scopes in this file, see the docstring that explains the two types of
  scope dependencies in clarifai/auth/scope/scope.proto

  For new endpoints you should typically only add the fully qualified url that includes the user_id
  and app_id.

  You should typicaly use KeyAuth (the most restricted auth type) for new endpoints unless they are
  for resources not contained in an app or need access from things across apps. See more about the
  auth types here:
  https://clarifai.atlassian.net/wiki/spaces/TT/pages/1821409336/API+Authorizers+and+Resource+Access

 */


service V2 {



  // List concept relations between concepts in the platform.
  // MUST be above ListConcepts so that if concept_id is empty this will still match
  // /concepts/relations to list all the concept relations in the app.
  rpc ListConceptRelations (ListConceptRelationsRequest) returns (MultiConceptRelationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/relations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }



  // Post concept relations to create relations between concepts in the platform.
  rpc PostConceptRelations (PostConceptRelationsRequest) returns (MultiConceptRelationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post concept relations to create relations between concepts in the platform.
  rpc DeleteConceptRelations (DeleteConceptRelationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the concepts with their positive and negative counts
  rpc GetConceptCounts (GetConceptCountsRequest) returns (MultiConceptCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/status"
      additional_bindings {
        get: "/v2/concepts/status"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific concept from an app.
  rpc GetConcept (GetConceptRequest) returns (SingleConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}"
      additional_bindings {
        get: "/v2/concepts/{concept_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the concepts.
  rpc ListConcepts (ListConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      additional_bindings {
        get: "/v2/concepts"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List models concepts.
  rpc ListModelConcepts (ListModelConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/concepts"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/concepts"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Search over the concepts to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc PostConceptsSearches (PostConceptsSearchesRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/searches"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // as it needs to know the concepts in your workflow's models.
  }

  // Add a concept to an app.
  rpc PostConcepts (PostConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      body: "*"
      additional_bindings {
        post: "/v2/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch one or more concepts.
  rpc PatchConcepts (PatchConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      body: "*"
      additional_bindings {
        patch: "/v2/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }











  // Get a specific concept from an app.
  rpc GetConceptLanguage (GetConceptLanguageRequest) returns (SingleConceptLanguageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages/{language}"
      additional_bindings {
        get: "/v2/concepts/{concept_id}/languages/{language}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List the concept in all the translated languages.
  rpc ListConceptLanguages (ListConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      additional_bindings {
        get: "/v2/concepts/{concept_id}/languages"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add a new translation for this concept.
  rpc PostConceptLanguages (PostConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/{concept_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch the name for a given language names by passing in a list of concepts with the new names
  // for the languages.
  rpc PatchConceptLanguages (PatchConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      body: "*"
      additional_bindings {
        patch: "/v2/concepts/{concept_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }




  // List all domain graphs.
  rpc ListKnowledgeGraphs (ListKnowledgeGraphsRequest) returns (MultiKnowledgeGraphResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs"
      additional_bindings {
        get: "/v2/concepts/knowledge_graphs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post domain graphs.
  rpc PostKnowledgeGraphs (PostKnowledgeGraphsRequest) returns (MultiKnowledgeGraphResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/knowledge_graphs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Start concept mapping jobs.
  rpc PostConceptMappingJobs (PostConceptMappingJobsRequest) returns (MultiConceptMappingJobResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings/jobs"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/mappings/jobs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }



  // Get a specific annotation from an app.
  rpc GetAnnotation (GetAnnotationRequest) returns (SingleAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}"
      additional_bindings {
        get: "/v2/inputs/{input_id}/annotations/{annotation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // List all the annotation.
  rpc ListAnnotations (ListAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      additional_bindings {
        get: "/v2/annotations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // Post annotations.
  rpc PostAnnotations (PostAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      body: "*"
      additional_bindings {
        post: "/v2/annotations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the models in your default workflow.
  }

  // Patch one or more annotations.
  rpc PatchAnnotations (PatchAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      body: "*"
      additional_bindings {
        patch: "/v2/annotations"
          body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the models in your default workflow.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // Patch annotations status by worker id and task id.
  rpc PatchAnnotationsStatus (PatchAnnotationsStatusRequest) returns (PatchAnnotationsStatusResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/task/{task_id}/annotations/status"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single annotation.
  rpc DeleteAnnotation (DeleteAnnotationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}"
      additional_bindings {
        delete: "/v2/inputs/{input_id}/annotations/{annotation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // for cleaning up some optimizations we have in DB layer for annotations.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete multiple annotations in one request.
  rpc DeleteAnnotations (DeleteAnnotationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/annotations"
      body: "*"
      additional_bindings {
        delete: "/v2/inputs/annotations"
          body: "*"
      }
      additional_bindings {
        delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
          body: "*"
      }
      additional_bindings {
        delete: "/v2/annotations"
          body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // for cleaning up some optimizations we have in DB layer for annotations.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Patch saved annotations searches by ids.
  rpc PatchAnnotationsSearches (PatchAnnotationsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches"
      body: "*"
      additional_bindings {
        patch: "/v2/annotations/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Execute a search over annotations
  rpc PostAnnotationsSearches(PostAnnotationsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches"
      body: "*"
      additional_bindings {
        post: "/v2/annotations/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // ListAnnotationWorkers lists users, models, and workflows (collectively
  // known as "workers") that have added annotations to the application.
  rpc ListAnnotationWorkers (ListAnnotationWorkersRequest) returns (MultiWorkerResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/workers"
      additional_bindings {
        get: "/v2/annotations/workers"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get input count per status.
  rpc GetInputCount (GetInputCountRequest) returns (SingleInputCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/status"
      additional_bindings {
        get: "/v2/inputs/status"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Streams all the inputs starting from oldest assets.
  rpc StreamInputs (StreamInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/stream"
      additional_bindings {
        get: "/v2/inputs/stream"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific input from an app.
  rpc GetInputSamples (GetInputSamplesRequest) returns (MultiInputAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/samples"
      additional_bindings {
        get: "/v2/tasks/{task_id}/inputs/samples"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific input from an app.
  rpc GetInput (GetInputRequest) returns (SingleInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}"
      additional_bindings {
        get: "/v2/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a video input manifest.
  rpc GetInputVideoManifest (GetVideoManifestRequest) returns (GetVideoManifestResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/video_manifest"
      additional_bindings {
        get: "/v2/inputs/{input_id}/video_manifest"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // List all the inputs.
  rpc ListInputs (ListInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      additional_bindings {
        get: "/v2/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Add 1 or more input to an app.
  // The actual inputs processing is asynchronous.
  rpc PostInputs (PostInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        post: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }




  // Patch one or more inputs.
  rpc PatchInputs (PatchInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        patch: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single input asynchronously.
  rpc DeleteInput (DeleteInputRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}"
      additional_bindings {
        delete: "/v2/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple inputs in one request.
  // This call is asynchronous.
  rpc DeleteInputs (DeleteInputsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        delete: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch saved inputs searches by ids.
  rpc PatchInputsSearches (PatchInputsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/searches"
      body: "*"
      additional_bindings {
        patch: "/v2/inputs/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Execute a search over inputs
  rpc PostInputsSearches(PostInputsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/searches"
      body: "*"
      additional_bindings {
        post: "/v2/inputs/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Get predicted outputs from the model.
  rpc PostModelOutputs (PostModelOutputsRequest) returns (MultiOutputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/outputs"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/{version_id}/outputs"
        body: "*"
      }
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/outputs"
        body: "*"
      }
      additional_bindings {
        post: "/v2/models/{model_id}/outputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
  }

  // List all the datasets.
  rpc ListDatasets (ListDatasetsRequest) returns (MultiDatasetResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/datasets"
      }
      additional_bindings {
        get: "/v2/datasets"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Get a specific dataset.
  rpc GetDataset (GetDatasetRequest) returns (SingleDatasetResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Add datasets to an app.
  // The process is atomic, i.e. either all or no datasets are added.
  // If there is an error for one dataset,
  // the process will stop, revert the transaction and return the error.
  rpc PostDatasets (PostDatasetsRequest) returns (MultiDatasetResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets"
      body: "*"
      additional_bindings {
        post: "/v2/datasets"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Patch one or more datasets.
  // The process is atomic, i.e. either all or no datasets are patched.
  // If there is an error for one dataset,
  // the process will stop, revert the transaction and return the error.
  rpc PatchDatasets (PatchDatasetsRequest) returns (MultiDatasetResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets"
      body: "*"
      additional_bindings {
        patch: "/v2/datasets"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Delete one or more datasets in a single request.
  rpc DeleteDatasets (DeleteDatasetsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets"
      body: "*"
      additional_bindings {
        delete: "/v2/datasets"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Delete;
  }

  // List all the dataset inputs in a dataset.
  rpc ListDatasetInputs (ListDatasetInputsRequest) returns (MultiDatasetInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Get a specific dataset input.
  rpc GetDatasetInput (GetDatasetInputRequest) returns (SingleDatasetInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs/{input_id}"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add dataset inputs to a dataset.
  // The process is not atomic, i.e. if there are errors with some dataset
  // inputs, others might still be added. The response reports
  //   - SUCCESS if all dataset inputs were added,
  //   - MIXED_STATUS if only some dataset inputs were added, and
  //   - FAILURE if no dataset inputs were added.
  // Each individual dataset input in the response has the status set to
  // indicate if it was successful or if there was an error.
  rpc PostDatasetInputs (PostDatasetInputsRequest) returns (MultiDatasetInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs"
      body: "*"
      additional_bindings {
        post: "/v2/datasets/{dataset_id}/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete one or more dataset inputs in a single request.
  rpc DeleteDatasetInputs (DeleteDatasetInputsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs"
      body: "*"
      additional_bindings {
        delete: "/v2/datasets/{dataset_id}/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // List all the dataset versions.
  rpc ListDatasetVersions (ListDatasetVersionsRequest) returns (MultiDatasetVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Get a specific dataset version.
  rpc GetDatasetVersion (GetDatasetVersionRequest) returns (SingleDatasetVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions/{dataset_version_id}"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/versions/{dataset_version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  rpc ListDatasetVersionMetricsGroups (ListDatasetVersionMetricsGroupsRequest) returns (MultiDatasetVersionMetricsGroupResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions/{dataset_version_id}/metrics"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/versions/{dataset_version_id}/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Add dataset versions to a dataset.
  rpc PostDatasetVersions (PostDatasetVersionsRequest) returns (MultiDatasetVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions"
      body: "*"
      additional_bindings {
        post: "/v2/datasets/{dataset_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch one or more dataset versions.
  rpc PatchDatasetVersions (PatchDatasetVersionsRequest) returns (MultiDatasetVersionResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions"
      body: "*"
      additional_bindings {
        patch: "/v2/datasets/{dataset_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
  }

  // Delete one or more dataset versions in a single request.
  rpc DeleteDatasetVersions (DeleteDatasetVersionsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions"
      body: "*"
      additional_bindings {
        delete: "/v2/datasets/{dataset_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Delete;
  }

  // Create export of a dataset version.
  rpc PutDatasetVersionExports (PutDatasetVersionExportsRequest) returns (MultiDatasetVersionExportResponse) {
    option (google.api.http) = {
      put: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions/{dataset_version_id}/exports"
      body: "*"
      additional_bindings {
        put: "/v2/datasets/{dataset_id}/versions/{dataset_version_id}/exports"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
  }


  ////////////////////////////////////////
  // Models
  ////////////////////////////////////////

  // Get a specific model type.
  rpc GetModelType (GetModelTypeRequest) returns (SingleModelTypeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/types/{model_type_id}"
      additional_bindings {
        get: "/v2/models/types/{model_type_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the supported open source licenses in the platform.
  rpc ListOpenSourceLicenses (ListOpenSourceLicensesRequest) returns (ListOpenSourceLicensesResponse) {
    option (google.api.http) = {
      get: "/v2/open_source_licenses"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // List all the model types available in the platform.
  // This MUST be above ListModels so that the /models/types endpoint takes precedence.
  rpc ListModelTypes (ListModelTypesRequest) returns (MultiModelTypeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/types"
      additional_bindings {
        get: "/v2/models/types"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a specific model from an app.
  rpc GetModel (GetModelRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}"
      additional_bindings {
        get: "/v2/models/{model_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a the output info for a given model_id or model_id/version_id
  // combo.
  rpc GetModelOutputInfo (GetModelRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/output_info"
      additional_bindings {
        get: "/v2/models/{model_id}/output_info"
      }
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/output_info"
      }
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/output_info"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the models.
  rpc ListModels (ListModelsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/models"
      }
      additional_bindings {
        get: "/v2/models"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List the resource counts for the app.
  rpc GetResourceCounts (GetResourceCountsRequest) returns (GetResourceCountsResponse){
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/resource_counts"
      additional_bindings {
        get: "/v2/resource_counts"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;

  }

  // Search over the models to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc PostModelsSearches (PostModelsSearchesRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/searches"
      body: "*"
      additional_bindings {
        post: "/v2/models/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Add a models to an app.
  rpc PostModels (PostModelsRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        post: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;  // Train is needed because it creates a new version.
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
  }

  // Patch one or more models.
  rpc PatchModels (PatchModelsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        patch: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
  }

  // Patch one or more models ids.
  rpc PatchModelIds (PatchModelIdsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/ids"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single model.
  rpc DeleteModel (DeleteModelRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}"
      additional_bindings {
        delete: "/v2/models/{model_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple models in one request.
  rpc DeleteModels (DeleteModelsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        delete: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Update model check consents
  rpc PatchModelCheckConsents (PatchModelCheckConsentsRequest) returns (MultiModelCheckConsentResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/check_consents"
      body: "*"
      additional_bindings {
        patch: "/v2/models/{model_id}/check_consents"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Update model toolkits tags
  rpc PatchModelToolkits (PatchModelToolkitsRequest) returns (MultiModelToolkitResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/toolkits"
      body: "*"
      additional_bindings {
        patch: "/v2/models/{model_id}/toolkits"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Update model use_cases tags
  rpc PatchModelUseCases (PatchModelUseCasesRequest) returns (MultiModelUseCaseResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/usecases"
      body: "*"
      additional_bindings {
        patch: "/v2/models/{model_id}/usecases"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Update model languages tags
  rpc PatchModelLanguages (PatchModelLanguagesRequest) returns (MultiModelLanguageResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/languages"
      body: "*"
      additional_bindings {
        patch: "/v2/models/{model_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the inputs.
  rpc ListModelInputs (ListModelInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/inputs"
      additional_bindings {
        get: "/v2/models/{model_id}/inputs"
      }
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/inputs"
      }
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a specific model from an app.
  rpc GetModelVersion (GetModelVersionRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the models.
  rpc ListModelVersions (ListModelVersionsRequest) returns (MultiModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      additional_bindings {
        get: "/v2/models/{model_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  rpc PostWorkflowVersionsUnPublish (PostWorkflowVersionsUnPublishRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/unpublish"
      body: "*"
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/unpublish"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowPublications_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  rpc PostWorkflowVersionsPublish (PostWorkflowVersionsPublishRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/publish"
      body: "*"
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/publish"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowPublications_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // PostModelVersionsPublish
  rpc PostModelVersionsPublish (PostModelVersionsPublishRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/publish"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/publish"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = ModelVersionPublications_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // PostModelVersionsUnPublish
  rpc PostModelVersionsUnPublish (PostModelVersionsUnPublishRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/unpublish"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/unpublish"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = ModelVersionPublications_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }


  // NOTE: inconsistency: do we want this to return a SingleModelResponse?

  // Create a new model version to trigger training of the model.
  rpc PostModelVersions (PostModelVersionsRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // PatchModelVersions
  rpc PatchModelVersions (PatchModelVersionsRequest) returns (MultiModelVersionResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
  }

  // Delete a single model.
  rpc DeleteModelVersion (DeleteModelVersionRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}"
      additional_bindings {
        delete: "/v2/models/{model_id}/versions/{version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Deprecated: Use GetEvaluation instead
  // Get the evaluation metrics for a model version.
  rpc GetModelVersionMetrics (GetModelVersionMetricsRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/metrics"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  // Deprecated, use PostEvaluations instead
  // Run the evaluation metrics for a model version.
  rpc PostModelVersionMetrics (PostModelVersionMetricsRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/metrics"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/{version_id}/metrics"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // Deprecated, use PostEvaluations instead
  rpc PostModelVersionEvaluations (PostModelVersionEvaluationsRequest) returns (MultiEvalMetricsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/evaluations"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/{model_version_id}/evaluations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // Deprecated, use GetEvaluation instead
  // List the evaluation metrics for a model version.
  rpc ListModelVersionEvaluations (ListModelVersionEvaluationsRequest) returns (MultiEvalMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/evaluations"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{model_version_id}/evaluations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  // Deprecated, use GetEvaluation instead
  // Get an evaluation metrics for a model version.
  rpc GetModelVersionEvaluation (GetModelVersionEvaluationRequest) returns (SingleEvalMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/evaluations/{evaluation_id}"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{model_version_id}/evaluations/{evaluation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  rpc PostEvaluations (PostEvaluationsRequest) returns (MultiEvalMetricsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/evaluations"
      body: "*"
      additional_bindings {
        post: "/v2/evaluations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  rpc ListEvaluations (ListEvaluationsRequest) returns (MultiEvalMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/evaluations"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/evaluations"
      }
      additional_bindings {
        get: "/v2/evaluations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  rpc GetEvaluation (GetEvaluationRequest) returns (SingleEvalMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/evaluations/{evaluation_id}"
      additional_bindings {
        get: "/v2/evaluations/{evaluation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  // Lists model references tied to a particular model id.
  rpc ListModelReferences (ListModelReferencesRequest) returns (MultiModelReferenceResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/references"
      additional_bindings {
        get: "/v2/models/{model_id}/references"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }



  // GetModelVersionInputExample
  rpc GetModelVersionInputExample (GetModelVersionInputExampleRequest) returns (SingleModelVersionInputExampleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/input_examples/{example_id}"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{model_version_id}/input_examples/{example_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // ListModelVersionInputExamples
  rpc ListModelVersionInputExamples (ListModelVersionInputExamplesRequest) returns (MultiModelVersionInputExampleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/input_examples"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{model_version_id}/input_examples"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }















  ////////////////////////////////////////

  ////////////////////////////////////////
  // Workflows
  ////////////////////////////////////////

  // Get a specific workflow from an app.
  rpc GetWorkflow (GetWorkflowRequest) returns (SingleWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the workflows.
  rpc ListWorkflows (ListWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/workflows"
      }
      additional_bindings {
        get: "/v2/workflows"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }


  // Add a workflow to an app.
  rpc PostWorkflows (PostWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        post: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch one or more workflows.
  rpc PatchWorkflows (PatchWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        patch: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch one or more workflows ids.
  rpc PatchWorkflowIds (PatchWorkflowIdsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/ids"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete a single workflow.
  rpc DeleteWorkflow (DeleteWorkflowRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}"
      additional_bindings {
        delete: "/v2/workflows/{workflow_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple workflows in one request.
  rpc DeleteWorkflows (DeleteWorkflowsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        delete: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Predict using a workflow.
  rpc PostWorkflowResults (PostWorkflowResultsRequest) returns (PostWorkflowResultsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_id}/results"
      body: "*"
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results"
        body: "*"
      }
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/results"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Compare embeddings distances using a workflow
  rpc PostWorkflowResultsSimilarity(PostWorkflowResultsSimilarityRequest) returns (PostWorkflowResultsSimilarityResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_id}/results/similarity"
      body: "*"
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results/similarity"
        body: "*"
      }
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/results/similarity"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List workflow versions.
  rpc ListWorkflowVersions (ListWorkflowVersionsRequest) returns (MultiWorkflowVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get single workflow version.
  rpc GetWorkflowVersion (GetWorkflowVersionRequest) returns (SingleWorkflowVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{workflow_version_id}"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}/versions/{workflow_version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete workflow versions.
  rpc DeleteWorkflowVersions (DeleteWorkflowVersionsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
      body: "*"
      additional_bindings {
        delete: "/v2/workflows/{workflow_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
  }

  // Patch workflow versions.
  rpc PatchWorkflowVersions (PatchWorkflowVersionsRequest) returns (MultiWorkflowVersionResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
      body: "*"
      additional_bindings {
        patch: "/v2/workflows/{workflow_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
  }






  // Get a specific key from an app.
  rpc GetKey (GetKeyRequest) returns (SingleKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/keys/{key_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List all the keys.
  rpc ListKeys (ListKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/keys"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List keys by app_id
  rpc ListAppKeys (ListAppKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/keys"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Search over the keys to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc DeleteKey (DeleteKeyRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/keys/{key_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Add a key to an app.
  rpc PostKeys (PostKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/keys"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Patch one or more keys.
  rpc PatchKeys (PatchKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/keys"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // API Keys in the public API -- request is itself Key authorized, and will tell
  // the user the scopes/access of the key/credential they're providing, as computed by
  // our authorizer:
  rpc MyScopes (MyScopesRequest) returns (MultiScopeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/myscopes"
      additional_bindings {
        get: "/v2/myscopes"
      }
      additional_bindings {
        get: "/v2/my_scopes"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  rpc MyScopesUser (MyScopesUserRequest) returns (MultiScopeUserResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/myscopes"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  rpc MyScopesRoot (MyScopesRootRequest) returns (MultiScopeRootResponse) {
    option (google.api.http) = {
      get: "/v2/myscopesroot"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // List all auth scopes available to me as a user.
  rpc ListScopes (ListScopesRequest) returns (MultiScopeDepsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/scopes"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get a specific app from an app.
  rpc GetApp (GetAppRequest) returns (SingleAppResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the apps.
  rpc ListApps (ListAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps"
      additional_bindings {
        get: "/v2/apps"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Search over the apps to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc DeleteApp (DeleteAppRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Add a app to an app.
  // This needs to load the default workflow to make a copy, validating all the models in it, and
  // then writing the new workflow back to this new app.
  rpc PostApps (PostAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
  }

  // Patch one or more apps.
  rpc PatchApps (PatchAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // Patch apps ids.
  rpc PatchAppsIds (PatchAppsIdsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/ids"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // Patch one app.
  rpc PatchApp (PatchAppRequest) returns (SingleAppResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }


  // Search over the applications to find one or more you're looking for.
  rpc PostAppsSearches (PostAppsSearchesRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/searches"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get user information
  rpc GetUser (GetUserRequest) returns (SingleUserResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }












  // Validate new password in real-time for a user
  rpc PostValidatePassword (PostValidatePasswordRequest) returns (SinglePasswordValidationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/validate_password"
      body: "*"
      additional_bindings {
        post: "/v2/validate_password"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }














































  // Get a saved legacy search.
  rpc GetSearch (GetSearchRequest) returns (SingleSearchResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      additional_bindings {
        get: "/v2/searches/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // List all saved legacy searches.
  rpc ListSearches (ListSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      additional_bindings {
        get: "/v2/searches"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Patch saved legacy searches by ids.
  rpc PatchSearches (PatchSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      body: "*"
      additional_bindings {
        patch: "/v2/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Execute a new search and optionally save it.
  //
  // Deprecated: Use PostInputsSearches or PostAnnotationsSearches instead.
  rpc PostSearches (PostSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      body: "*"
      additional_bindings {
        post: "/v2/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
    option deprecated = true;
  }

  // Execute a previously saved legacy search.
  rpc PostSearchesByID (PostSearchesByIDRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      body: "*"
      additional_bindings {
        post: "/v2/searches/{id}"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // Evaluate the results of two search requests
  rpc PostAnnotationSearchMetrics(PostAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics"
      body: "*"
      additional_bindings {
        post: "/v2/annotations/searches/metrics"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // as it needs to know the concepts in your workflow's models.
  }

  // Get the evaluation results between two search requests
  rpc GetAnnotationSearchMetrics(GetAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}"
      additional_bindings {
        get: "/v2/annotations/searches/metrics/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }



  // List the evaluation results between two search requests
  rpc ListAnnotationSearchMetrics(ListAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics"
      additional_bindings {
        get: "/v2/annotations/searches/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  // DeleteAnnotationSearchMetrics
  rpc DeleteAnnotationSearchMetrics (DeleteAnnotationSearchMetricsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}"
      additional_bindings {
        delete: "/v2/annotations/searches/metrics/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Delete;
  }

  // Delete a saved search.
  rpc DeleteSearch (DeleteSearchRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      additional_bindings {
        delete: "/v2/searches/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Delete;
  }


  // List all the annotation filters.
  rpc ListAnnotationFilters (ListAnnotationFiltersRequest) returns (MultiAnnotationFilterResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters"
      additional_bindings {
        get: "/v2/annotation_filters"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Get a specific annotation filter.
  rpc GetAnnotationFilter (GetAnnotationFilterRequest) returns (SingleAnnotationFilterResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters/{annotation_filter_id}"
      additional_bindings {
        get: "/v2/annotation_filters/{annotation_filter_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Add annotation filters.
  rpc PostAnnotationFilters (PostAnnotationFiltersRequest) returns (MultiAnnotationFilterResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters"
      body: "*"
      additional_bindings {
        post: "/v2/annotation_filters"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
  }

  // Patch one or more annotation filters.
  rpc PatchAnnotationFilters (PatchAnnotationFiltersRequest) returns (MultiAnnotationFilterResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters"
      body: "*"
      additional_bindings {
        patch: "/v2/annotation_filters"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
  }

  // Delete one or more annotation filters in a single request.
  rpc DeleteAnnotationFilters (DeleteAnnotationFiltersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters"
      body: "*"
      additional_bindings {
        delete: "/v2/annotation_filters"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
  }































  // List all status codes.
  rpc ListStatusCodes (ListStatusCodesRequest) returns (MultiStatusCodeResponse) {
    option (google.api.http) = {
      get: "/v2/status_codes"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Get more details for a status code.
  rpc GetStatusCode (GetStatusCodeRequest) returns (SingleStatusCodeResponse) {
    option (google.api.http) = {
      get: "/v2/status_codes/{status_code_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }











  // owner list users who the app is shared with
  rpc ListCollaborators (ListCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
  }

  // add collaborators to an app.
  rpc PostCollaborators (PostCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
  }

  // Patch existing collaborators.
  rpc PatchCollaborators (PatchCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Delete;
  }

  // Delete existing collaborators.
  rpc DeleteCollaborators (DeleteCollaboratorsRequest) returns (clarifai.api.status.BaseResponse){
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add; // when deleting a collaborator, we also delete task workers associated to this collaborator
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Collaboration includes the app user are invitied to work on
  rpc ListCollaborations (ListCollaborationsRequest) returns (MultiCollaborationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/collaborations"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }





  // start to duplicate an app which copies all the inputs, annotations, models, concepts etc. to a new app.
  // this is an async process, you should use ListAppDuplications or GetAppDuplication to check the status.
  rpc PostAppDuplications (PostAppDuplicationsRequest) returns (MultiAppDuplicationsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/duplications"
        body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // list all the app duplications user triggers
  rpc ListAppDuplications (ListAppDuplicationsRequest) returns (MultiAppDuplicationsResponse){
    option (google.api.http) = {
      get : "/v2/users/{user_app_id.user_id}/duplications"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // get the app duplication status
  rpc GetAppDuplication (GetAppDuplicationRequest) returns (SingleAppDuplicationResponse) {
    option (google.api.http) = {
      get : "/v2/users/{user_app_id.user_id}/duplications/{app_duplication_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // Add tasks to an app.
  rpc PostTasks (PostTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        post: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional, needed for add_task_annotations.go when saved search uses visual search
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add; // needed for add_task_annotations.go
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get; // needed for add_task_annotations.go
  }

  // Task annotation count
  rpc GetTaskAnnotationCount (GetTaskCountRequest) returns (SingleTaskCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/annotations/count"
      additional_bindings {
        get: "/v2/tasks/{task_id}/annotations/count"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Task Input count
  rpc GetTaskInputCount (GetTaskCountRequest) returns (SingleTaskCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/count"
      additional_bindings {
        get: "/v2/tasks/{task_id}/inputs/count"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Get a specific task from an app.
  rpc GetTask (GetTaskRequest) returns (SingleTaskResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}"
      additional_bindings {
        get: "/v2/tasks/{task_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // List tasks from an app.
  rpc ListTasks (ListTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      additional_bindings {
        get: "/v2/tasks"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // Patch one or more tasks.
  rpc PatchTasks (PatchTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        patch: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional, needed for add_task_annotations.go when saved search uses visual search
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add; // needed for add_task_annotations.go
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get; // needed for add_task_annotations.go
  }

  // Delete multiple tasks in one request.
  rpc DeleteTasks (DeleteTasksRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        delete: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Delete;
  }



  ////////////////////////////////////////
  // Label Order
  ////////////////////////////////////////

  // Add Label orders.
  rpc PostLabelOrders (PostLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings {
        post: "/v2/label_orders"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // Get a label order.
  rpc GetLabelOrder (GetLabelOrderRequest) returns (SingleLabelOrderResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders/{label_order_id}"
      additional_bindings {
        get: "/v2/label_orders/{label_order_id}"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get; // needed because task is embedded
  }

  // List label orders.
  rpc ListLabelOrders (ListLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      additional_bindings {
        get: "/v2/label_orders"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get; // needed because task is embedded
  }

  // Patch one or more label orders.
  rpc PatchLabelOrders (PatchLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings {
        patch: "/v2/label_orders"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Delete;
  }

  // Delete multiple label orders in one request.
  // this do not change task status
  rpc DeleteLabelOrders (DeleteLabelOrdersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings {
        delete: "/v2/label_orders"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Add a list of Collectors to an app.
  // In the handler of this endpoint we also check for all the scopes of the  POST /inputs
  // endpoint.
  // Those current scopes are listed here as a hard requirement.
  // They are needed when adding the collectors just so we now that you have permission with
  // that key at least to do the writing to this app with POST /inputs.
  rpc PostCollectors (PostCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        post: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get a specific collector from an app.
  rpc GetCollector (GetCollectorRequest) returns (SingleCollectorResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors/{collector_id}"
      additional_bindings {
        get: "/v2/collectors/{collector_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // List all the collectors.
  rpc ListCollectors (ListCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      additional_bindings {
        get: "/v2/collectors"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // Patch one or more collectors.
  rpc PatchCollectors (PatchCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        patch: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }



  // Delete multiple collectors in one request.
  // This call is asynchronous. Use DeleteCollector if you want a synchronous version.
  rpc DeleteCollectors (DeleteCollectorsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        delete: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // PostStatValues
  rpc PostStatValues (PostStatValuesRequest) returns (MultiStatValueResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values"
      body: "*"
      additional_bindings {
        post: "/v2/stats/values"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // PostStatValuesAggregate
  rpc PostStatValuesAggregate (PostStatValuesAggregateRequest) returns (MultiStatValueAggregateResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values/aggregate"
      body: "*"
      additional_bindings {
        post: "/v2/stats/values/aggregate"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }








  // Increase the view metric for a detail view
  rpc PostTrendingMetricsView (PostTrendingMetricsViewRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/trending_metrics/views/{view_type}/{object_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // List the view metrics for a detail view
  rpc ListTrendingMetricsViews (ListTrendingMetricsViewsRequest) returns (MultiTrendingMetricsViewResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/trending_metrics/views/{view_type}"
      additional_bindings {
        get: "/v2/trending_metrics/views/{view_type}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }









  // Get a specific module from an app.
  rpc GetModule (GetModuleRequest) returns (SingleModuleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // List all the modules in community, by user or by app.
  rpc ListModules (ListModulesRequest) returns (MultiModuleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/modules"
      }
      additional_bindings {
        get: "/v2/modules"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Add a modules to an app.
  rpc PostModules (PostModulesRequest) returns (MultiModuleResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Patch one or more modules.
  rpc PatchModules (PatchModulesRequest) returns (MultiModuleResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Delete multiple modules in one request.
  rpc DeleteModules (DeleteModulesRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get; // Needed to cascade delete to IMV
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
  }

  // Get a specific module version for a module.
  rpc GetModuleVersion (GetModuleVersionRequest) returns (SingleModuleVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/versions/{module_version_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // List all the modules versions for a given module.
  rpc ListModuleVersions (ListModuleVersionsRequest) returns (MultiModuleVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/versions"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Create a new module version to trigger training of the module.
  rpc PostModuleVersions (PostModuleVersionsRequest) returns (MultiModuleVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Delete a multiple module version.
  rpc DeleteModuleVersions (DeleteModuleVersionsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get; // Needed to cascade delete to IMV
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
  }

  // Get installed modules vesrions for an app.
  rpc GetInstalledModuleVersion (GetInstalledModuleVersionRequest) returns (SingleInstalledModuleVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions/{installed_module_version_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List installed modules vesrions for an app.
  rpc ListInstalledModuleVersions (ListInstalledModuleVersionsRequest) returns (MultiInstalledModuleVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Install a new module version which will deploy the specific ModuleVersion to the app in the url.
  rpc PostInstalledModuleVersions (PostInstalledModuleVersionsRequest) returns (MultiInstalledModuleVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get; // since adding Keys needs that.
  }

  // Uninstall an installed module version which will deploy the specific ModuleVersion to the app
  // in the url.
  // This cleaned up any associated caller keys so needs the Keys_Delete scope.
  rpc DeleteInstalledModuleVersions (DeleteInstalledModuleVersionsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Assign a key that the caller owns to be used when accessing this installed module version
  // If this endpoint is called with a different key then it overwrites what is there.
  rpc PostInstalledModuleVersionsKey (PostInstalledModuleVersionsKeyRequest) returns (SingleKeyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions/{installed_module_version_id}/key"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get; // since adding Keys needs that.
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Perform bulk operations on a list of inputs based on input source.
  // Operation include add, update, delete of concepts, metadata and geo data.
  // This is an Asynchronous process. Use ListBulkOperations or GetBulkOperation to check the status.
  rpc PostBulkOperations (PostBulkOperationsRequest) returns (MultiBulkOperationsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations"
      body: "*"
      additional_bindings {
        post: "/v2/bulk_operations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
  }

  // List all the bulk operations
  rpc ListBulkOperations (ListBulkOperationsRequest) returns (MultiBulkOperationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations"
      additional_bindings {
        get: "/v2/bulk_operations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
  }

  // Get the bulk operation details by ID
  rpc GetBulkOperation (GetBulkOperationRequest) returns (SingleBulkOperationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations/{id}"
      additional_bindings {
        get: "/v2/bulk_operations/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
  }

  // Cancel one or more bulk operations
  rpc CancelBulkOperations (CancelBulkOperationRequest) returns (MultiBulkOperationsResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations"
      body: "*"
      additional_bindings {
        patch: "/v2/bulk_operations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Add;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
  }

  // delete one or more terminated bulk operations
  rpc DeleteBulkOperations (DeleteBulkOperationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations"
      body: "*"
      additional_bindings {
        delete: "/v2/bulk_operations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Add;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Delete;
  }

  // Get a specific job.
  rpc GetDatasetInputsSearchAddJob (GetDatasetInputsSearchAddJobRequest) returns (SingleDatasetInputsSearchAddJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/inputs/search_add/jobs/{job_id}"
      additional_bindings {
        get: "/v2/datasets/inputs/search_add/jobs/{job_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
  }

  // List next non-labeled and unassigned inputs from task's dataset
  rpc ListNextTaskAssignments (ListNextTaskAssignmentsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/assignments"
      additional_bindings {
        get: "/v2/tasks/{task_id}/assignments"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
  }

  // PutTaskAssignments evaluates all the annotations by labeler (authenticated user) for given task (task_id) and input (input_id).
  rpc PutTaskAssignments (PutTaskAssignmentsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      put: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/assignments"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
  }



  // List all the inputs add jobs
  rpc ListInputsAddJobs (ListInputsAddJobsRequest) returns (MultiInputsAddJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/add"
      additional_bindings {
        get: "/v2/inputs/jobs/add"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get the input add job details by ID
  rpc GetInputsAddJob (GetInputsAddJobRequest) returns (SingleInputsAddJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/add/{id}"
      additional_bindings {
        get: "/v2/inputs/jobs/add/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // cancel the input add job by ID
  rpc CancelInputsAddJob (CancelInputsAddJobRequest) returns (SingleInputsAddJobResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/add/{id}"
      body: "*"
      additional_bindings {
        patch: "/v2/inputs/jobs/add/{id}"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  rpc PostUploads (PostUploadsRequest) returns (MultiUploadResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads"
      body: "*"
      additional_bindings {
        post: "/v2/uploads"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }

  // Upload a part of a multipart upload.
  // Behaviour on completion depends on the endpoint that was used to initiate the upload.
  rpc PutUploadContentParts (PutUploadContentPartsRequest) returns (SingleUploadResponse) {
    option (google.api.http) = {
      put: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads/{upload_id}/content_parts"
      additional_bindings {
        put: "/v2/uploads/{upload_id}/content_parts"
      }
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }

  rpc GetUpload (GetUploadRequest) returns (SingleUploadResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads/{upload_id}"
      additional_bindings {
        get: "/v2/uploads/{upload_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }

  rpc ListUploads (ListUploadsRequest) returns (MultiUploadResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads"
      additional_bindings {
        get: "/v2/uploads"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }

  rpc DeleteUploads (DeleteUploadsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads"
      body: "*"
      additional_bindings {
        delete: "/v2/uploads"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Delete;
  }

  // Initiates retrieval of inputs from cloud storage from a user provided data source.
  // Will create and return an inputs-add-job for tracking progress.
  // Archives will be extracted and their contents will be processed as inputs.
  //
  // The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
  // files in the images_folder beginning with abc or in a subfolder beginning with abc.
  // For example:
  // bucket/images_folder/abcImage.png
  // bucket/images_folder/abc-1/Data.zip
  //
  // If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
  // Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
  // in which case it only requires rights to access that particular file.
  rpc PostInputsDataSources (PostInputsDataSourcesRequest) returns (MultiInputsAddJobResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/data_sources"
      body: "*"
      additional_bindings {
        post: "/v2/inputs/data_sources"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get the input extraction job details by ID
  rpc GetInputsExtractionJob (GetInputsExtractionJobRequest) returns (SingleInputsExtractionJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/extraction/{inputs_extraction_job_id}"
      additional_bindings {
        get: "/v2/inputs/jobs/extraction/{inputs_extraction_job_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // List all the input extraction jobs
  rpc ListInputsExtractionJobs (ListInputsExtractionJobsRequest) returns (MultiInputsExtractionJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/extraction"
      additional_bindings {
        get: "/v2/inputs/jobs/extraction"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  rpc CancelInputsExtractionJobs (CancelInputsExtractionJobsRequest) returns (MultiInputsExtractionJobResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/extraction"
      body: "*"
      additional_bindings {
        patch: "/v2/inputs/jobs/extraction"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Start uploading a file archive containing inputs.
  // Will create and return an inputs-add-job for tracking progress.
  //
  // Associated inputs-add-job contains an upload id which should be completed through `PutUploadContentParts` endpoint.
  // Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
  rpc PostInputsUploads (PostInputsUploadsRequest) returns (MultiInputsAddJobResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/uploads"
      body: "*"
      additional_bindings {
        post: "/v2/inputs/uploads"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }



  // Get a specific runner from an app.
  rpc GetRunner (GetRunnerRequest) returns (SingleRunnerResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/runners/{runner_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Get;
  }

  // List all the runners in community, by user or by app.
  rpc ListRunners (ListRunnersRequest) returns (MultiRunnerResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/runners"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Get;
  }

  // Add a runners to an app.
  rpc PostRunners (PostRunnersRequest) returns (MultiRunnerResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/runners"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Add;
  }

  // Delete multiple runners in one request.
  rpc DeleteRunners (DeleteRunnersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/runners"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Delete;
  }

  // List items for the remote runner to work on.
  rpc ListRunnerItems (ListRunnerItemsRequest) returns (MultiRunnerItemResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/runners/{runner_id}/items"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Get;
    option (clarifai.auth.util.cl_depending_scopes) = RunnerItems_Get;
  }

  // Post back outputs from remote runners
  rpc PostRunnerItemOutputs (PostRunnerItemOutputsRequest) returns (MultiRunnerItemOutputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/runners/{runner_id}/items/{item_id}/outputs"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Runners_Get;
    option (clarifai.auth.util.cl_depending_scopes) = RunnerItems_Get;
    option (clarifai.auth.util.cl_depending_scopes) = RunnerItems_Add;
  }  // Get the training time estimate based off train request and estimated input count.
  rpc PostModelVersionsTrainingTimeEstimate (PostModelVersionsTrainingTimeEstimateRequest) returns (MultiTrainingTimeEstimateResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/time_estimate"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/time_estimate"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }}






// Split the results into pages.
message Pagination {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults to 128.
  uint32 per_page = 2;
}

// GetAnnotationRequest
message GetAnnotationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string annotation_id = 2;
  string input_id = 3;
}

// ListAnnotationsRequest
message ListAnnotationsRequest {
  reserved 4;

  clarifai.api.UserAppIDSet user_app_id = 1;

  // List annotations for these IDs
  repeated string ids = 2;

  // List annotations for these Input IDs
  // Note that 'ids' are optional but if the are provided the number and order in
  // 'ids' and 'input_ids' should match
  // If you do not specify 'ids' all the annotations for 'input_ids' are returned
  // If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
  repeated string input_ids = 3;

  // Only return the annotations that has one of these user IDs, effectively operating as an
  // OR among them to filter down the results.
  // If model_version_ids are also provided these user_ids are OR'd with them as well since
  // annotations are either provided by users or model versions and we want the union of any
  // provided user or model version annotations in the results of ListAnnotations request.
  // If no user_ids are provided then annotations from all users are returned.
  repeated string user_ids = 9;

  // Only return the annotations that has one of these model version IDs, effectively operating as an
  // OR among them to filter down the results.
  // If user_ids are also provided these model_versions_ids are OR'd with them as well since
  // annotations are either provided by users or model versions and we want the union of any
  // provided user or model version annotations in the results of ListAnnotations request.
  // If no model_version_ids are provided then annotations from all model versions are returned.
  repeated string model_version_ids = 10;

  // Set status to filter by a list of statuses
  // If not statuses are provided then annotations with any status will be returned.
  repeated clarifai.api.status.Status statuses = 5;

  // Set this flag to list both trusted and not trusted annotations
  // by default it's listing only trusted annotations
  bool list_all_annotations = 6;

  // Set this flag to return the model output for model annotations in the response.
  bool return_model_output = 12;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 7;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 8;
  // Flag to filter annotations by task_id
  string task_id = 11;
}

// PostAnnotationsRequest
message PostAnnotationsRequest {

  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Annotation annotations = 2;
}

// PatchAnnotationsRequest
message PatchAnnotationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Annotation annotations = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;

  // If the request is a "remove" action and the annotation is left with empty data,
  // then setting delete_if_empty_data to true will delete the annotation,
  // if possible (for example, will not delete an input-level annotation).
  bool delete_if_empty_data = 4;
}

// PatchAnnotationsStatusRequest
message PatchAnnotationsStatusRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Annotation Status code
  clarifai.api.status.StatusCode status_code = 2;
  repeated string user_ids = 3;
  string task_id = 4;
  // 'overwrite' is supported
  string action = 5;

}

// PatchAnnotationsStatusResponse
message PatchAnnotationsStatusResponse {
  clarifai.api.status.Status status = 1;
  repeated string user_ids = 2;
  uint32 updated_count = 3;
}

// DeleteAnnotationRequest
message DeleteAnnotationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string input_id = 2;

  string annotation_id = 3;
}

// Request to delete several things by the list of ids.
message DeleteAnnotationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Delete annotations with IDs
  repeated string ids = 2;

  // Delete annotations for these Input IDs
  // Note that 'ids' are optional but if the are provided the number and order in
  // 'ids' and 'input_ids' should match
  // If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
  // However you need to specify at least one value for 'input_ids'
  // i.e. this API does not support deleting all annotations
  repeated string input_ids = 3;
}

// SingleAnnotationResponse
message SingleAnnotationResponse {
  clarifai.api.status.Status status = 1;
  Annotation annotation = 2;
}

// MultiAnnotationResponse
message MultiAnnotationResponse {
  clarifai.api.status.Status status = 1;

  repeated Annotation annotations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListAnnotationWorkersRequest
message ListAnnotationWorkersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // (optional URL parameter) List of additional fields to be included in the response.
  // Currently supported: all, names
  repeated string additional_fields = 4;

  // (optional URL parameter) Only list workers that have created trusted annotations.
  bool trusted_only = 5;
}

// MultiWorkerResponse
message MultiWorkerResponse {
  clarifai.api.status.Status status = 1;

  repeated Worker workers = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GetAppRequest
message GetAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 2;
}

// ListAppsRequest
message ListAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 10;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 5;
  oneof sort_by {
    // Whether to order by the name
    bool sort_by_name = 6;
    // Whether to order by the modified_at time.
    // If none of the sort options is set to true, will sort by modified_at.
    bool sort_by_modified_at = 7;
    // Whether to order by the created_at time.
    bool sort_by_created_at = 12;
    // Whether to order by the number of users stared the app
    bool sort_by_star_count = 13;
  }

  // Filtering options:
  // If true, we only return apps that are handpicked by clarifai staff
  bool featured_only = 9;
  // If true, we only return apps that are starred by the requesting user
  bool starred_only = 11;

  // Searching options:
  // Specify a search parameter in order to perform keyword search on the
  // following fields of the application:
  //   - id
  //   - name
  //   - description
  //   - notes
  //   - user_id (unless user_app_id.user_id is already set)
  //
  // Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  // and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  //
  // NOTE: Both the list of fields searched and the exact keyword matching
  // rules are subject to change and not guaranteed to be backwards-compatible.
  string search = 15;
  // Query various text fields (id, name, description, and notes) that can contain the words in the query string
  // Deprecated: use search instead.
  string query = 8 [deprecated = true];
  // Filter by the id, name and notes of the app. This supports wilcard queries like "gen*" to match "general" as an example.
  // Deprecated: use search instead.
  string name = 4 [deprecated = true];
  // Filter by the user-unique-id of the app. This supports wilcard queries like "gen*" to match "general" as an example.
  // Deprecated: use search instead.
  string id = 14 [deprecated = true];
}

// PostAppsRequest
message PostAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated App apps = 2;
}

// DeleteAppRequest
message DeleteAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// PatchAppsRequest
message PatchAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated App apps = 2;

  // The action to perform on the patched App objects except App.Metadata
  // Supported values: 'overwrite' and 'remove'.
  //
  // Note that 'remove' can only be used to remove the app image by setting
  // 'image.url' in the request to the current value returned for that app.
  string action = 3;

  // The action to perform on the patched App.Metadata
  clarifai.api.PatchAction metadata_action = 4;

  // If set, the app will be automatically reindexed upon change of its base workflow.
  bool reindex = 5;
}

// PatchAppRequest
message PatchAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  App app = 2;

  // The action to perform on the patched App object except App.Metadata
  // Supported values: 'overwrite' and 'remove'.
  //
  // Note that 'remove' can only be used to remove the app image by setting
  // 'image.url' in the request to the current value returned for the app.
  string action = 3;

  // The action to perform on the patched App.Metadata
  clarifai.api.PatchAction metadata_action = 4;

  // If set, the app will be automatically reindexed upon change of its base workflow.
  bool reindex = 5;
}


// PatchAppsIdsRequest
message PatchAppsIdsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Array containing 1 entry
  repeated IdUpdateSource ids = 3;

  // The action to perform on the patched objects
  // Only 'overwrite' is supported
  string action = 4;
}

// Search over the available applications.
message PostAppsSearchesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  AppQuery app_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

// SingleAppResponse
message SingleAppResponse {
  clarifai.api.status.Status status = 1;
  App app = 2;
}

// MultiAppResponse
message MultiAppResponse {
  clarifai.api.status.Status status = 1;
  repeated App apps = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListCollaboratorsRequest
message ListCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Set this flag to list both deleted and not deleted collaborators
  // by default it's listing only not deleted collaborators
  bool list_all_collaborators = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// PostCollaboratorsRequest
message PostCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collaborator collaborators = 2;
}

// PatchCollaboratorsRequest
message PatchCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collaborator collaborators = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// DeleteCollaboratorsRequest
message DeleteCollaboratorsRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string collaborator_ids = 2;
  repeated string user_emails = 3;
}

// MultiCollaboratorsResponse
message MultiCollaboratorsResponse {
  clarifai.api.status.Status status = 1;
  repeated Collaborator collaborators = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListCollaborationsRequest
message ListCollaborationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// MultiCollaborationsResponse
message MultiCollaborationsResponse {
  clarifai.api.status.Status status = 1;
  repeated Collaboration collaborations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}




































// GetStatusCodeRequest
message GetStatusCodeRequest {
  string status_code_id = 1;
}

// ListStatusCodesRequest
message ListStatusCodesRequest {
}

// SingleStatusCodeResponse
message SingleStatusCodeResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

// MultiStatusCodeResponse
message MultiStatusCodeResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.status.Status statuses = 2;
}

// GetConceptRequest
message GetConceptRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept's id.
  string concept_id = 2;
}

// ListConceptsRequest
message ListConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
  // Fuzzy match on concept ID
  string id = 4;
}

// ListModelConceptsRequest
message ListModelConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Model id
  string model_id = 2;
  // Model version Id. Optional, if not provided latest model version is used.
  string version_id = 3;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;
}

// PostConceptsSearchesRequest
message PostConceptsSearchesRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  ConceptQuery concept_query = 2;

  // Request additional info to be retrieved for each concept in the response.
  ConceptExtraInfoRequest extra_info = 4;

  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

message ConceptExtraInfoRequest {
  // Determine if the concept is searchable by rank using this model.
  // Currently, only embedder models are supported.
  // ########## Supported fields ##########
  // - app_id
  // - id
  // - model_version.id
  // - user_id
  Model rankable_model = 1;
}

// PostConceptsRequest
message PostConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concepts to add.
  repeated Concept concepts = 2;
}

// PatchConceptsRequest
message PatchConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concepts to patch.
  repeated Concept concepts = 2;

  // The action to perform on the patched objects
  // For now ony action 'overwrite' is supported
  string action = 3;
}

// GetConceptCountsRequest
message GetConceptCountsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// SingleConceptResponse
message SingleConceptResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept.
  Concept concept = 2;
}

// MultiConceptResponse
message MultiConceptResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concepts.
  repeated Concept concepts = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// MultiConceptCountResponse
message MultiConceptCountResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept counts.
  repeated ConceptCount concept_counts = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GET all relations such that the concept_id refers to the subject of the relation
message ListConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The subject concept id in your app to get all the relationships for.
  // Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
  //
  // When listing all the relations it will only return one direction of the relationship
  // with the predicate acting on the subject and not the inverse like is done when providing a
  // concept_id so that we can return a reliable page size always.
  //
  // When providing a concept_id, if a hyponym is present in the DB such as:
  // 'honey' (subject), 'hyponym' (predicate for "is a kind of"), 'food' (object)
  // then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
  // object.
  // But you can also list the concept relations for 'food' and it will return the same hyponym
  // relationship with 'honey' as object and 'hypernym' as predicate.
  // Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
  // when listing the relations.
  string concept_id = 2;
  // If predicate is provided then only list relations with that predicate.
  //
  // Note that if no subject is set in concept_id and predicate is set to
  // 'hypernym', then it will return any stored hyponyms as hypernyms with
  // just the subject and object swapped since they are reversed relations.
  //
  // Valid predicates are:
  // - 'hypernym'
  // - 'hyponym'
  // - 'synonym'
  string predicate = 3;
  // If knowledge_graph_id is provided then just list relations from that knowledge graph.
  // If not provided then list relations from all knowledge graphs including the global one for this
  // app one (ie. knowledge_graph "") and any specific ones in the app.
  string knowledge_graph_id = 4;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 5;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 6;
}

// POST new concept relations
message PostConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The subject concept id you're going to add relations for.
  string concept_id = 2;
  // The relationships you're going to add.
  repeated ConceptRelation concept_relations = 3;
}

// DELETE concept relations
message DeleteConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept to delete relationship for.
  string concept_id = 2;
  // The concept relationship ids to delete.
  repeated string ids = 3;
}

// GET all knowledge graphs
message ListKnowledgeGraphsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// POST new knowledge graphs
message PostKnowledgeGraphsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated KnowledgeGraph knowledge_graphs = 2;
}



// Start concept mapping jobs
message PostConceptMappingJobsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept mapping jobs that are being started
  repeated ConceptMappingJob concept_mapping_jobs = 2;
}


// MultiConceptRelationResponse
message MultiConceptRelationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept relations.
  repeated ConceptRelation concept_relations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}


// MultiKnowledgeGraphResponse
message MultiKnowledgeGraphResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned knowledge graphs.
  repeated KnowledgeGraph knowledge_graphs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}




// MultiConceptMappingJobResponse
message MultiConceptMappingJobResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The ids of the concept mapping jobs underway.
  repeated string ids = 2;
}

// GET single concept language for the given concept.
message GetConceptLanguageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  // This is the language identifier.
  string language = 3;
}

// List multiple concept languages for the given concept.
message ListConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// PATCH multiple concept languages for the given concept.
message PatchConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  repeated ConceptLanguage concept_languages = 3;
  // The action to perform with the objects in the PATCH.
  string action = 4;
}



// // DELETE multiple concept languages for the given concept.
// message DeleteConceptLanguageRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   string concept_id = 2;
//   // The language code to delete.
//   string language = 3;
// }

// // DELETE multiple concept languages for the given concept.
// message DeleteConceptLanguagesRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   string concept_id = 2;
//   // The language code(s) to delete.
//   string ids = 3;
//   bool delete_all = 4;
// }

// POST multiple concept languages for the given concept.
message PostConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  repeated ConceptLanguage concept_languages = 3;
}

// SingleConceptLanguageResponse
message SingleConceptLanguageResponse {
  clarifai.api.status.Status status = 1;
  ConceptLanguage concept_language = 2;
}

// MultiConceptLanguageResponse
message MultiConceptLanguageResponse {
  clarifai.api.status.Status status = 1;
  repeated ConceptLanguage concept_languages = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}






// GetInputRequest
message GetInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}// GetInputRequest
message GetVideoManifestRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}

// GetInputSamplesRequest
message GetInputSamplesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
  // URL param. If zero ids provided, returns for all task labelers
  repeated string user_ids = 3;
}

// ListInputsRequest
message ListInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Set status to filter by status
  clarifai.api.status.Status status = 5;

  repeated string ids = 4;
}

// StreamInputsRequest
message StreamInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;
  string last_id = 3;

  // By default, the endpoint return inputs by the time when it is added.
  // If this is set to true, we will return inputs by id.
  bool order_by_id = 5;
  bool descending = 4;
}

// PostInputsRequest
message PostInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of inputs to post.
  // For each input, the following fields are used:
  // * id
  // * data
  // * dataset_ids
  repeated Input inputs = 2;

  // Collect statistics about created inputs in job with given ID.
  // * If job ID is empty, then job is not created.
  // * If job ID is non-empty and doesn't already exist, then a new job will be created with given ID.
  // * If job ID does already exist, then new inputs statistics are merged with previous inputs statistics.
  string inputs_add_job_id = 3;

  // How to handle input ID conflicts.
  InputIDConflictResolution input_id_conflict_resolution = 4;
}





// PatchInputsRequest
message PatchInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of inputs to patch.
  // Inputs are identified by id field.
  // For each input, the following fields are patchable:
  // * data
  repeated Input inputs = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// DeleteInputRequest
message DeleteInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteInputsRequest {
  reserved 3;

  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// SingleInputResponse
message SingleInputResponse {
  clarifai.api.status.Status status = 1;
  Input input = 2;
}

message GetVideoManifestResponse {
  clarifai.api.status.Status status = 1;

  // MPEG-dash manifest as data-URI, base64-encoded
  // Can be empty if status is FAILED
  // Can be fallback manifest if status is MIXED_STATUS
  string manifest_url = 2;
}

// MultiInputResponse
message MultiInputResponse {

  clarifai.api.status.Status status = 1;
  repeated Input inputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];

  InputsAddJob inputs_add_job = 3;
}

// MultiInputAnnotationResponse
message MultiInputAnnotationResponse {

  clarifai.api.status.Status status = 1;
  repeated Hit hits = 3 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleInputCountResponse
message SingleInputCountResponse {
  clarifai.api.status.Status status = 1;

  InputCount counts = 2;
}

// GetInputCountRequest
message GetInputCountRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// ListDatasetsRequest
message ListDatasetsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  repeated string additional_fields = 5;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 6;
  oneof sort_by {
    // Whether to order by the created_at time.
    bool sort_by_created_at = 7;
    // Whether to order by the number of users stared the app
    bool sort_by_star_count = 8;
    // If neither sort option is set to true, will sort by modified_at.
    bool sort_by_modified_at = 9;
    // Whether to order by the external id
    bool sort_by_id = 11;
  }

  // Filtering options:
  bool starred_only = 4;
  // Filter datasets by bookmark. If set, only return bookmarked datasets. Otherwise none bookmarked datasets only.
  bool bookmark = 10;

  // Searching options:
  // Specify a search parameter in order to perform keyword search on the
  // following fields of the dataset:
  //   - id
  //   - description
  //   - notes
  //   - user_id (unless user_app_id.user_id is already set)
  //
  // Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  // and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  //
  // NOTE: Both the list of fields searched and the exact keyword matching
  // rules are subject to change and not guaranteed to be backwards-compatible.
  string search = 13;
  // Fuzzy filter on dataset ID
  // Deprecated: use search instead.
  string id = 12 [deprecated = true];
}

// GetDatasetRequest
message GetDatasetRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;
  repeated string additional_fields = 3;
}

// Request to add one or more datasets.
message PostDatasetsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of datasets that are requested to be added.
  repeated Dataset datasets = 2;
}

// Request to patch several datasets.
message PatchDatasetsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of datasets that are requested to be updated.
  repeated Dataset datasets = 2;

  // The action to perform on the patched objects
  // Supported values: 'overwrite', 'merge', and 'remove'.
  //
  // Note that 'remove' can only be used to remove the dataset image by setting
  // 'image.url' in the request to the current value returned for that dataset.
  string action = 3;
}

// Request to delete several datasets by list of ids.
message DeleteDatasetsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string dataset_ids = 2;
}

// MultiDatasetResponse
message MultiDatasetResponse {
  clarifai.api.status.Status status = 1;
  repeated Dataset datasets = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleDatasetResponse
message SingleDatasetResponse {
  clarifai.api.status.Status status = 1;
  Dataset dataset = 2;
}

// ListDatasetInputsRequest
message ListDatasetInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Identify dataset by id.
  string dataset_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// GetDatasetInputRequest
message GetDatasetInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Identify dataset input by id.
  string input_id = 3;
}

// Request to add one or more datasets.
message PostDatasetInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // List of inputs that are requested to be added to this dataset.
  // Identify each input by id field. All other inputs fields are ignored.
  repeated DatasetInput dataset_inputs = 3;

  // Query to search inputs to be added to this dataset.
  Search search = 4;
}

// Request to delete several dataset inputs by list of ids.
message DeleteDatasetInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Specify which inputs to delete from dataset.
  repeated string input_ids = 3;
}

// MultiDatasetInputResponse
message MultiDatasetInputResponse {
  clarifai.api.status.Status status = 1;
  repeated DatasetInput dataset_inputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  DatasetInputsSearchAddJob dataset_inputs_search_add_job = 3;
}

// SingleDatasetInputResponse
message SingleDatasetInputResponse {
  clarifai.api.status.Status status = 1;
  DatasetInput dataset_input = 2;
}

// ListDatasetVersionsRequest
message ListDatasetVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// GetDatasetVersionRequest
message GetDatasetVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Identify dataset version by id.
  string dataset_version_id = 3;
}

// ListDatasetVersionMetricsGroupsRequest
message ListDatasetVersionMetricsGroupsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Identify dataset version by id.
  string dataset_version_id = 3;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;

  // Filter by parent path. Multiple parent paths are OR-ed. Empty list results in no filter.
  repeated string parent_paths = 6;

  // Filter by parent type. Multiple types are OR-ed. Empty list results in no filter.
  repeated DatasetVersionMetricsGroupType types = 7;

  // Filter by value. Multiple values are OR-ed. Empty list results in no filter.
  repeated google.protobuf.Value values = 8;
}

// Request to add one or more dataset versions.
message PostDatasetVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // List of dataset versions that are requested to be added.
  repeated DatasetVersion dataset_versions = 3;
}

// Request to patch several dataset versions.
message PatchDatasetVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // List of dataset versions that are requested to be updated.
  repeated DatasetVersion dataset_versions = 3;

  // The action to perform on the patched objects
  // For now, only 'overwrite' action is supported
  string action = 4;
}

// Request to delete several dataset versions by list of ids.
message DeleteDatasetVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  repeated string dataset_version_ids = 3;
}

// Request to create exports of a dataset version.
message PutDatasetVersionExportsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Identify dataset version by id.
  string dataset_version_id = 3;

  // exports is the list of requested dataset version exports.
  // Only setting the 'format' field of the export is supported.
  repeated DatasetVersionExport exports = 4;
}

message MultiDatasetVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated DatasetVersion dataset_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiDatasetVersionExportResponse {
  clarifai.api.status.Status status = 1;
  repeated DatasetVersionExport exports = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiDatasetVersionMetricsGroupResponse {
  clarifai.api.status.Status status = 1;
  repeated DatasetVersionMetricsGroup dataset_version_metrics_groups = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message SingleDatasetVersionResponse {
  clarifai.api.status.Status status = 1;
  DatasetVersion dataset_version = 2;
}

message GetDatasetInputsSearchAddJobRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string job_id = 2;
}

message SingleDatasetInputsSearchAddJobResponse {
  clarifai.api.status.Status status = 1;

  DatasetInputsSearchAddJob job = 2;
}

////////////////////////////////////////////////////
// Model prediction related stuff needs inputs and produces outputs.
////////////////////////////////////////////////////
// Model prediction.
message PostModelOutputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  repeated Input inputs = 4;
  // This allows you to specify config options for the model such as
  // the language which appear's in the model's output_info.
  Model model = 5;
}

// Listing the inputs that went into training this model.
message ListModelInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;
}

// GetKeyRequest
message GetKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string key_id = 2;
}

// ListKeysRequest
message ListKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
  bool not_expired = 4;
  repeated string scopes = 5;
  repeated string endpoints = 6;
}

// ListAppKeysRequest
message ListAppKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostKeysRequest
message PostKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Key keys = 2;
}

// DeleteKeyRequest
message DeleteKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string key_id = 2;
}

// PatchKeysRequest
message PatchKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Key keys = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// SingleKeyResponse
message SingleKeyResponse {
  clarifai.api.status.Status status = 1;
  Key key = 2;
}

// MultiKeyResponse
message MultiKeyResponse {
  clarifai.api.status.Status status = 1;
  repeated Key keys = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}









// GetModelRequest
message GetModelRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  // This is included so that we can re-use this request for multiple
  // rpcs with and without the version_id.
  string version_id = 3;
  string language = 4;
  bool trained_before = 5;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
  repeated string additional_fields = 19;
}

// ListModelsRequest
message ListModelsRequest {
  reserved 4;
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
  repeated string additional_fields = 19;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 10;
  oneof sort_by {
    // Whether to order by the name
    bool sort_by_name = 11;
    // Whether to order by the number of training inputs
    bool sort_by_num_inputs = 12;
    // Whether to order by the modified_at time of the latest model version.
    // If none of the sort options is set to true, will sort by modified_at.
    bool sort_by_modified_at = 13;
    // Whether to order by the created_at
    bool sort_by_created_at = 24;
    // Whether to order by count of stars
    bool sort_by_star_count = 25;
  }

  // Filtering options:
  // Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
  // supported.
  string model_type_id = 6;
  // If true, we only return models that have the status MODEL_TRAINED, which includes non-trainable model types.
  bool trained_only = 7;
  // The list of input fields to the model.
  // For example, you can specify 'image', which will return models that make inferences on images like visual-classifier models.
  repeated string input_fields = 8;
  // The list of output fields to the model.
  // For example, you can specify 'regions[...].data.concepts', which will return visual-detector models.
  repeated string output_fields = 9;
  // Filter by the license of the model version
  string license = 15;
  // If true, we only return models that are handpicked by clarifai staff
  bool featured_only = 16;
  // If true, we only return models that are starred by the requesting user
  bool starred_only = 20;
  // List of toolkit tags to filter by
  repeated string toolkits = 17;
  // List of use_case tags to filter by
  repeated string use_cases = 18;
  // List of language tags to filter by
  repeated string languages = 21;
  // Old API behavior resulted in returning clarifai main models when calling ListModels while scoped to an app. While we transition
  // away from that, we can use this flag to not always fetch clarifai main models, unless that is the app we are explicitly listing for.
  bool dont_fetch_from_main = 23;
  // Filter models by bookmark. If set, only return bookmarked models. Otherwise none bookmarked models only.
  // Note: you can not filter `trained_only` and bookmark at the same time.
  // When filter by bookmark, we will return trained and untrained models.
  bool bookmark = 26;

  // Searching options:
  // Specify a search parameter in order to perform keyword search on the
  // following fields of the model:
  //   - id
  //   - name
  //   - description
  //   - notes
  //   - user_id (unless user_app_id.user_id is already set)
  //
  // Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  // and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  //
  // NOTE: Both the list of fields searched and the exact keyword matching
  // rules are subject to change and not guaranteed to be backwards-compatible.
  string search = 27;
  // Query name, description and id fields, that can contain the words in the query string. Does NOT support wildcards - full words only. Supports operators "OR" and "-" as NOT.
  // Deprecated: use search instead.
  string query = 14 [deprecated = true];
  // Filter by the description and id of the model. This supports wildcard queries like "gen*" to match "general" as an example.
  // Deprecated: use search instead.
  string name = 5 [deprecated = true];
  // Extends the name filter to include the user_id of the application owner that the model belongs to.
  // Deprecated: use search instead of name.
  bool filter_by_user_id = 22 [deprecated = true];
}

// ResourceCountRequest
message GetResourceCountsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// ResourceCountResponse
message GetResourceCountsResponse {
  clarifai.api.status.Status status = 1;
  int64 datasets = 2;
  int64 models = 3;
  int64 workflows = 4;
  int64 modules = 5;
}

message PatchModelToolkitsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;

  repeated string toolkits = 3;
  //overwrite supported
  string action = 4;
}

// PatchModelCheckConsentsRequest
message PatchModelCheckConsentsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // the model id
  string model_id = 2;
  // the consents
  repeated string check_consents = 3;
  //overwrite supported
  string action = 4;
}

message PatchModelUseCasesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;

  repeated string usecases = 3;
  //overwrite supported
  string action = 4;
}

message PatchModelLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;

  repeated string languages = 3;
  // Only overwrite supported
  string action = 4;
}



message MultiModelToolkitResponse {
  clarifai.api.status.Status status = 1;
  repeated string toolkits = 2;
}

message MultiModelCheckConsentResponse {
  clarifai.api.status.Status status = 1;
  repeated string check_consents = 2;
}

message MultiModelUseCaseResponse {
  clarifai.api.status.Status status = 1;
  repeated string usecases = 2;
}

message MultiModelLanguageResponse {
  clarifai.api.status.Status status = 1;
  repeated string languages = 2;
}

// PostModelsRequest
message PostModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // NOTE: inconsistent since "model" is not plural, please use "models" below.
  // Previously you could only create one model at a time.
  // We still support this but you should pass it as models=[model] so
  // that this endpoint is consistent with the rest of our API.
  Model model = 2 [deprecated = true];
  // This allows you to create one or more model by posting it to the API.
  repeated Model models = 3;
}

// PatchModelsRequest
message PatchModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Model models = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  //
  // Note that 'remove' can be used to remove the model image by setting
  // 'image.url' in the request to the current value returned for that model.
  // This cannot be used in a request that is patching other fields as well.
  string action = 3;
}

message IdUpdateSource {
  //old id
  string id = 1;
  //new id
  string new_id = 2;
}

// PatchModelIdsRequest
message PatchModelIdsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Array containing 1 entry
  repeated IdUpdateSource ids = 3;

  // The action to perform on the patched objects
  // Only 'overwrite' is supported
  string action = 4;
}

// DeleteModelRequest
message DeleteModelRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// Search over the available models.
message PostModelsSearchesRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  ModelQuery model_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

// SingleModelResponse
message SingleModelResponse {
  clarifai.api.status.Status status = 1;
  Model model = 2;
}

// MultiModelResponse
message MultiModelResponse {
  clarifai.api.status.Status status = 1;
  repeated Model models = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PatchModelVersionsRequest
message PatchModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersion model_versions = 3;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 4;
}

// request for different endpoints currently.
message GetModelVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
}

// ListModelVersionsRequest
message ListModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;

  // Filtering options:
  // To list only the model versions that have these concept ids present in them.
  repeated string concept_ids = 5;
  // To list only the model versions that have been trained.
  bool trained_only = 6;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 7;
  oneof sort_by {
    // Whether to order by the status code
    bool sort_by_status_code = 8;
    // Whether to order by the number of training inputs
    bool sort_by_num_inputs = 9;
    // Whether to sort by the description
    bool sort_by_description = 10;
    // Whether to order by the created_at time
    // If neither sort option is set to true, will sort by created_at.
    bool sort_by_created_at = 11;
  }
}

// DeleteModelVersionRequest
message DeleteModelVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 3;
  string version_id = 4;
}

// SingleModelVersionResponse
message SingleModelVersionResponse {
  clarifai.api.status.Status status = 1;
  ModelVersion model_version = 2;
}

// MultiModelVersionResponse
message MultiModelVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated ModelVersion model_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Create (train) a new model version.
message PostModelVersionsRequest {
  reserved 4, 5, 6, 7, 9;
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;

  repeated ModelVersion model_versions = 3;

  // Description about this training run
  string description = 8;

  // When evaluate_after_training set to true, we will do evaluation immediately after training finishes.
  // We will merge this with default_eval_info.
  EvalInfo eval_info = 10;
}

message PostWorkflowVersionsUnPublishRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
  repeated WorkflowVersionUnPublishRequest publications = 3;
}



message PostWorkflowVersionsPublishRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
  repeated WorkflowVersionPublishRequest publications = 3;
}

message WorkflowVersionPublishRequest {
  string version_id = 1;
}

message WorkflowVersionUnPublishRequest {
  string version_id = 1;
}

// ModelVersionPublishRequest
message ModelVersionPublishRequest {
  string version_id = 1;
}

// PostModelVersionsPublishRequest
message PostModelVersionsPublishRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersionPublishRequest publications = 3;
}

// ModelVersionUnpublishRequest
message ModelVersionUnpublishRequest {
  string version_id = 1;
}

// PostModelVersionsUnPublishRequest
message PostModelVersionsUnPublishRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersionUnpublishRequest publications = 3;
}

// Evaluate this model vesion
message PostEvaluationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // eval_info, id, model, and ground_truth_dataset will be used when creating the evaluation
  // If no dataset is provided, all app data that is annotated with concepts from the model will be used.
  repeated EvalMetrics eval_metrics = 2;
}

message ListEvaluationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
  // If true, sort in ascending order, otherwise sort in descending order.
  bool sort_ascending = 4;
  oneof sort_by {
    // Whether to order by application id
    bool sort_by_app_id = 5;
    // Whether to order by eval metric summary.macro_avg_roc_auc
    bool sort_by_roc_auc = 6;
    // Whether to order by eval metric summary.f1
    bool sort_by_f1 = 7;
    // Whether to order by when the metric was created
    bool sort_by_created_at = 8;
    // Whether to order by eval metric summary.mean_avg_precision_iou_50
    bool sort_by_mean_avg_precision = 9;
    // Whether to order by eval metric summary.macro_avg_precision
    bool sort_by_precision = 10;
    // Whether to order by eval metric summary.macro_avg_recall
    bool sort_by_recall = 11;
    bool sort_by_model_id = 16;
    bool sort_by_eval_dataset_id = 17;
    bool sort_by_train_dataset_id = 18;
  }
  // Filter on model type id
  string model_type_id = 12;
  // Filter on dataset ID of the dataset version specified in the metric version
  repeated string eval_dataset_ids = 13;
  // Filter on dataset ID of the dataset version specified by the model version
  repeated string train_dataset_ids = 14;
  // Filter on concept IDs specified in the modele version's output_info
  repeated string concept_ids = 15;
  // Whether to show failed metrics, defaults to false
  bool show_failed_metrics = 19; 
}

message GetEvaluationRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
  string evaluation_id = 2;
  // Any of the fields you wish to return in the metrics
  // By default, only the summary is returned.
  FieldsValue fields = 3;
}



// Evaluate this model vesion
message PostModelVersionEvaluationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string model_version_id = 3;
  // EvalInfo and ID will be used when creating the evaluation
  repeated EvalMetrics eval_metrics = 4;
}

message ListModelVersionEvaluationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string model_version_id = 3;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;
}

message GetModelVersionEvaluationRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string model_version_id = 3;
  string evaluation_id = 4;

  // Any of the fields you wish to return from multiclass_metrics
  // By default, only the summary is returned.
  FieldsValue fields = 5;
}

message SingleEvalMetricsResponse {
  clarifai.api.status.Status status = 1;
  EvalMetrics eval_metrics = 2;
}

message MultiEvalMetricsResponse {
  clarifai.api.status.Status status = 1;
  repeated EvalMetrics eval_metrics = 2;
}

// Evaluate this model version.
message PostModelVersionMetricsRequest {
  reserved 4;
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;

  // Use this to filter inputs that are used in evaluation
  clarifai.api.Search test_search = 5;

  // evaluation info. Such as dataset used for evaluation.
  EvalInfo eval_info = 10;
}

// Get the already computed evaluation metrics for this model
// version.
message GetModelVersionMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;

  // Any of the fields you wish to return from multiclass_metrics
  // By default, only the summary will be returned
  FieldsValue fields = 4;
}




// // Request to delete several things by the list of ids.
// message DeleteModelVersionsRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   repeated string ids = 2;
//   bool delete_all = 3;
// }

// GetModelTypeRequest
message GetModelTypeRequest {
  // use and app combo. Not really used for this endpoint at this time so may go away in future.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The specific ModelType.Id you want to retrieve.
  string model_type_id = 2;
}

// ListModelTypesRequest
message ListModelTypesRequest {
  // use and app combo. Not really used for this endpoint at this time so may go away in future.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// ListOpenSourceLicensesRequest
message ListOpenSourceLicensesRequest {}

// ListOpenSourceLicensesResponse
message ListOpenSourceLicensesResponse {
  clarifai.api.status.Status status = 1;
  repeated string licenses = 2;
}

// SingleModelTypeResponse
message SingleModelTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // The retrieved ModelType object. .
  ModelType model_type = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// MultiModelTypeResponse
message MultiModelTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // List of ModelType objects.
  repeated ModelType model_types = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  // List of model importers
  ModelTypeField model_importers = 3;
  // Triton model envs that can be used for model upload
  repeated TritonCondaEnvInfo triton_conda_envs_info= 4;
}

// GetModelVersionInputExampleRequest
message GetModelVersionInputExampleRequest {
  // authorization field  (contains app/user id info)
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of model the example belongs to
  string model_id = 2;
  // specific version the example belongs to
  string model_version_id = 3;
  // Id of example to fetch
  string example_id = 4;
}

// ListModelVersionInputExamplesRequest
message ListModelVersionInputExamplesRequest {
  // authorization field  (contains app/user id info)
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of model the example belongs to
  string model_id = 2;
  // specific version the example belongs to
  string model_version_id = 3;
  // Optional, defaults to 1.
  uint32 page = 4;
  // Optional, defaults to 128 references per page.
  uint32 per_page = 5;
}



// SingleModelVersionInputExampleResponse
message SingleModelVersionInputExampleResponse {
  // status of response
  clarifai.api.status.Status status = 1;
  // model input example message
  ModelVersionInputExample model_version_input_example = 2;
}

// MultiModelVersionInputExampleResponse
message MultiModelVersionInputExampleResponse {
  // status of response
  clarifai.api.status.Status status = 1;
  // model input example messages
  repeated ModelVersionInputExample model_version_input_examples = 2;
}

// ListModelReferencesRequest
message ListModelReferencesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;
  // Optional, defaults to 1.
  uint32 page = 3;
  // Optional, defaults to 128 references per page.
  uint32 per_page = 4;
}



// MultiModelReferenceResponse
message MultiModelReferenceResponse {
  clarifai.api.status.Status status = 1;
  repeated ModelReference model_references = 2;
}

// MultiOutputResponse
message MultiOutputResponse {
  clarifai.api.status.Status status = 1;
  repeated Output outputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListScopesRequest
message ListScopesRequest {
  // If "personal_access_token" include scopes and endpoints available to personal access tokens.
  // If "api_key" include scopes and endpoints available to app-specific keys. (default)
  string key_type = 1;

  // For all user specific information we include user_app_id to get the user_id in a consistent way
  clarifai.api.UserAppIDSet user_app_id = 2;
}

// MyScopesRequest
message MyScopesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MyScopesUserRequest
message MyScopesUserRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MyScopesRootRequest
message MyScopesRootRequest {
}

// MultiScopeDepsResponse
message MultiScopeDepsResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // scopes is a list of low-level scopes and their dependencies.
  repeated ScopeDeps scope_deps = 2;
  // endpoint_scopes is a listof all the publicly available endponts which can be
  // used as scopes as well. A call to each of those endpoint depends on a subset
  // of the above "scopes"
  repeated EndpointDeps endpoint_deps = 3;
}

// MultiScopeResponse
message MultiScopeResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // This is a list of the scopes that your key has.
  repeated string scopes = 2;
  // The app that the key has access to.
  App app = 3;
  // This is a list of endpoint permissions that your key has.
  repeated string endpoints = 4;
  string user_feature_flags = 5;
}

// MultiScopeUserResponse
message MultiScopeUserResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // This is a list of the scopes that your key has.
  repeated string scopes = 2;
  // This is a list of endpoint permissions that your key has.
  repeated string endpoints = 4;
  string user_feature_flags = 5;
}

// MultiScopeRootResponse
message MultiScopeRootResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // This is a list of the scopes that your key has.
  repeated string scopes = 2;
  // This is a list of endpoint permissions that your key has.
  repeated string endpoints = 4;
  string user_feature_flags = 5;
}

// GetSearchRequest
message GetSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// ListSearchesRequest
message ListSearchesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostSearchesRequest
message PostSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The query; this specifies how the data to be searched
  // this will be replaced by "Searches"
  Query query = 2 [deprecated=true];

  // The searched to be executed or saved
  // Eventually the request level fields will be deprecated in favor of this object
  repeated Search searches = 3;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 4;
}

message PatchInputsSearchesRequest{
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searches to be patched
  repeated Search searches = 2;

  // The action to perform on the patched Search objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

message PatchAnnotationsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searches to be patched
  repeated Search searches = 2;

  // The action to perform on the patched Search objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// PatchSearchesRequest
message PatchSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searches to be patched
  repeated Search searches = 2;

  // The action to perform on the patched Search objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// PostSearchesByIDRequest performs returns results of a saved search given its ID
message PostSearchesByIDRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // ID for saves search to be executed
  string id = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

// DeleteSearchRequest
message DeleteSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}


// Execute a new annotation search and optionally save it
// annotation search over annotations using rank and filter proto
message PostAnnotationsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searched to be executed or saved
  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

// DeleteAnnotationSearchMetricsRequest
message DeleteAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// Execute a new input search and optionally save it
message PostInputsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searched to be executed or saved
  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;

  // If only_count is set, then the response will not contain hits,
  // but hit_counts instead.
  bool only_count = 4;
}

// SingleSearchResponse returns saved search in response to GetSearchRequest
message SingleSearchResponse {
  // Status of whether the search was successful.
  clarifai.api.status.Status status = 1;
  Search search = 5;
}

// MultiSearchResponse
message MultiSearchResponse {
  // Status of whether the search was successful.
  clarifai.api.status.Status status = 1;

  // A unique id which uniquely identifies a search
  string id = 2;

  // The list of search result Hits.
  repeated Hit hits = 3 [(clarifai.api.utils.cl_show_if_empty) = true];

  // The original query provided in the request.
  Query query = 4;

  // The original Searches provided in the request.
  repeated Search searches = 5;

  // The counts of hits for each search, in the same order as searches.
  // Only returned if the request set only_count.
  repeated HitCount hit_counts = 6;
}

// PostAnnotationSearchMetricsRequest
message PostAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // A unique customer facing id to identify this eval request
  string id = 2;

  // The ground truth we are evaluating against
  clarifai.api.Search ground_truth = 3;

  // The set we are evaluating
  clarifai.api.Search search_to_eval = 4;

  // List of concepts to evaluate are expected to be in data.concepts
  // If nil, then all app concepts are used
  Data data = 5;

  // The type of evaluation to use
  EvaluationType evaluation_type = 6;
}

// GetAnnotationSearchMetricsRequest
message GetAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Unique custom facing id that identifies the eval to get
  string id = 2;
}

// ListAnnotationSearchMetricsRequest
message ListAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MultiAnnotationSearchMetricsResponse
message MultiAnnotationSearchMetricsResponse {
  // Status of the request
  clarifai.api.status.Status status = 1;
  repeated AnnotationSearchMetrics annotation_search_metrics = 2;
}

// ListAnnotationFiltersRequest
message ListAnnotationFiltersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// GetAnnotationFilterRequest
message GetAnnotationFilterRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify annotation filter by id.
  string annotation_filter_id = 2;
}

// Request to add one or more annotation filters.
message PostAnnotationFiltersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of annotation filters that are requested to be added.
  repeated AnnotationFilter annotation_filters = 2;
}

// Request to patch several annotation filters.
message PatchAnnotationFiltersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of annotation filters that are requested to be updated.
  repeated AnnotationFilter annotation_filters = 2;

  // The action to perform on the patched objects
  // For now, only 'overwrite' action is supported
  string action = 3;
}

// Request to delete several annotation filters by list of ids.
message DeleteAnnotationFiltersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Specify which filters to delete.
  repeated string annotation_filter_ids = 2;
}

// MultiAnnotationFilterResponse
message MultiAnnotationFilterResponse {
  clarifai.api.status.Status status = 1;

  repeated AnnotationFilter annotation_filters = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleAnnotationFilterResponse
message SingleAnnotationFilterResponse {
  clarifai.api.status.Status status = 1;

  AnnotationFilter annotation_filter = 2;
}

































// GetUserRequest
message GetUserRequest {
  // we used to have user_id but moved to the standard convention. Since this endpoint
  // hasn't been exposed and only used by portal as a url this won't effect anything external.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 2;
}



// SingleUserResponse
message SingleUserResponse {
  clarifai.api.status.Status status = 1;
  User user = 2;
}















// PostValidatePasswordRequest
message PostValidatePasswordRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // password to be validated
  Password password = 2;
}

// SinglePasswordValidationResponse
message SinglePasswordValidationResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  PasswordViolations password_violations = 2;
}


























enum OrganizationInvitationStatus {
  NOT_SET = 0;
  PENDING = 1;
  ACCEPTED = 2;
  CANCELLED = 3;
  DECLINED = 4;
  EXPIRED = 5;
}




















































// GetWorkflowRequest
message GetWorkflowRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Workflow ID to retrieve
  // If no ID is specified we return default workflow of the application
  // If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  string workflow_id = 2;

  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 3;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 4;

  // if true will not expand search to clarifai workflows
  bool exclude_clarifai_workflows = 5;
}

// ListWorkflowsRequest
message ListWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 10;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 5;
  oneof sort_by {
    // Whether to order by the name
    bool sort_by_id = 6;
    // Whether to order by the modified_at time.
    // If none of the sort options is set to true, will sort by modified_at.
    bool sort_by_modified_at = 7;

    // Whether to order by the created_at time.
    bool sort_by_created_at = 13;
    // Whether to order by the number of users stared the workflow
    bool sort_by_star_count = 14;
  }

  // Filtering options:
  // If true, we only return workflows that are handpicked by clarifai staff
  bool featured_only = 9;
  // If true, we only return workflows that are starred by the requesting user
  bool starred_only = 11;
  // Filter workflows by bookmark. If set, only return bookmarked workflows. Otherwise none bookmarked workflows only.
  bool bookmark = 15;

  // Searching options:
  // Specify a search parameter in order to perform keyword search on the
  // following fields of the workflow:
  //   - id
  //   - description
  //   - notes
  //   - user_id (unless user_app_id.user_id is already set)
  //
  // Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  // and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  //
  // NOTE: Both the list of fields searched and the exact keyword matching
  // rules are subject to change and not guaranteed to be backwards-compatible.
  string search = 16;
  // Query various text fields (id, description and notes) that can contain the words in the query string.
  // Deprecated: use search instead.
  string query = 8 [deprecated = true];
  // Filter by the id of the workflow. This supports wilcard queries like "gen*" to match "general" as an example.
  // Deprecated: use search instead.
  string id = 4 [deprecated = true];
  // Full text and prefix matching on id, owner id, description and notes. Searchable fields may be added
  // Deprecated: use search instead.
  string search_term = 12 [deprecated = true];
}


// PostWorkflowsRequest
message PostWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Workflow workflows = 2;
}

// PatchWorkflowsRequest
message PatchWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Workflow workflows = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  //
  // Note that 'remove' can be used to remove the workflow image by setting
  // 'image.url' in the request to the current value returned for that workflow.
  // This cannot be used in a request that is patching other fields as well.
  string action = 3;
}

// PatchWorkflowIdsRequest
message PatchWorkflowIdsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Array containing 1 entry
  repeated IdUpdateSource ids = 3;

  // The action to perform on the patched objects
  // Only 'overwrite' is supported
  string action = 4;
}

// DeleteWorkflowRequest
message DeleteWorkflowRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// SingleWorkflowResponse
message SingleWorkflowResponse {
  clarifai.api.status.Status status = 1;
  Workflow workflow = 2;
}

// MultiWorkflowResponse
message MultiWorkflowResponse {
  clarifai.api.status.Status status = 1;
  repeated Workflow workflows = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostWorkflowResultsRequest
message PostWorkflowResultsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Workflow ID to retrieve
  // If no ID is specified we return default workflow of the application
  // If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  string workflow_id = 2;

  // Workflow version ID to retrieve
  // If no ID is specified, latest workflow version is used
  string version_id = 7;

  repeated Input inputs = 3;
  // FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
  // to be within models. This is not consistent with setting this on the request for post model
  // outputs where it is inside a model object. To make this consistent we would send in the
  // workflow object so that each model can have it's own output config. If nobody is setting
  // this OutputConfig it would probably be easier to just remove it for now to keep things simpler
  // and then it's more consistent we just don't support the OutputConfig on workflows.
  OutputConfig output_config = 4;

  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 5;

  // A workflow state to be maintained across PostWorkflowResults requests/responses.
  // If it is not sent in the initial request with workflow_state.id = "init" then no
  // state will be saved or returned in PostWorkflowResultsResponse.
  WorkflowState workflow_state = 6;
}

// PostWorkflowResultsResponse
message PostWorkflowResultsResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // The workflow that was used in predictions with PostWorkflowResults
  Workflow workflow = 2;
  // The resulting predictions of all models in the workflow.
  repeated WorkflowResult results = 3;
  // A workflow state to be maintained across PostWorkflowResults requests/responses.
  // This WorkflowState should be passed in to subsequent PostWorkflowResults calls
  // if you want to keep track of state across requests.
  // If no WorkflowState was initialized in a request then no WorkflowState will be returned in this
  // response.
  WorkflowState workflow_state = 4;
}

// PostWorkflowResultsSimilarityRequest
message PostWorkflowResultsSimilarityRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
  // Workflow version ID to retrieve
  // If no ID is specified, latest workflow version is used
  string version_id = 7;
  // The specific model version whose outputs we are comparing
  string model_version_id = 3;
  // Each probe is compared against every pool input
  repeated Input probe_inputs = 4;
  // Each pool input is compared against ever probe input
  repeated Input pool_inputs = 5;
  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 6;
}

// PostWorkflowResultsSimilarityResponse
message PostWorkflowResultsSimilarityResponse {
  clarifai.api.status.Status status = 1;
  repeated WorkflowResultsSimilarity results = 2;
}

// ListWorkflowVersionsRequest
message ListWorkflowVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List versions for the workflow identified by this id
  string workflow_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// GetWorkflowVersionRequest
message GetWorkflowVersionRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested version.
    string workflow_id = 2;
    // Get the identified by this id
    string workflow_version_id = 3;
}

// DeleteWorkflowVersionsRequest
message DeleteWorkflowVersionsRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested versions to delete.
    string workflow_id = 2;
    // Delete the versions identified by these ids
    repeated string workflow_version_ids = 3;
}

// PatchWorkflowVersionsRequest
message PatchWorkflowVersionsRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested versions to patch.
    string workflow_id = 2;
    // Patch these versions.
    repeated WorkflowVersion workflow_versions = 3;
    // The action to perform on the patched objects
    // For now actions 'merge', 'overwrite', and 'remove' are supported
    string action = 4;
}

// MultiWorkflowVersionResponse
message MultiWorkflowVersionResponse {
    clarifai.api.status.Status status = 1;
    repeated WorkflowVersion workflow_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleWorkflowVersionResponse
message SingleWorkflowVersionResponse {
    clarifai.api.status.Status status = 1;
    WorkflowVersion workflow_version = 2;
}









//Request to start a app duplication process
message PostAppDuplicationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated AppDuplication app_duplications = 2;
}

//Request to check app duplication status
message GetAppDuplicationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  //The app duplication id
  string app_duplication_id = 2;
}

//Request to list all the app duplication that user triggered.
message ListAppDuplicationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// MultiAppDuplicationsResponse
message MultiAppDuplicationsResponse {
  clarifai.api.status.Status status = 1;
  repeated AppDuplication app_duplications = 2;
}

// SingleAppDuplicationResponse
message SingleAppDuplicationResponse {
  clarifai.api.status.Status status = 1;
  AppDuplication app_duplication = 2;
}

// Request to create Tasks.
message PostTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Task tasks = 2;
}

// Request to get one task.
message GetTaskRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;

  // (optional URL parameter) List of additional fields to be included in the response.
  // Currently supported: all, worker.users, review.users.
  repeated string additional_fields = 3;
}

// Request to list multiple tasks.
message ListTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
  // Get tasks that have ANY user from this list assigned as worker.
  repeated string worker_user_ids = 4;
  // Get tasks that have ANY user from this list assigned as reviewer.
  repeated string review_user_ids = 5;
  // Get tasks that are associated to ANY label order from this list.
  repeated string label_order_ids = 8;

  // Get label order tasks as well
  // It is automatically set to true if label_order_ids is set.
  bool including_label_order_tasks = 6;

  // (optional URL parameter) List of additional fields to be included in the response.
  // Currently supported: all, worker.users, review.users.
  repeated string additional_fields = 7;
}

// Request to patch a list of tasks.
message PatchTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Task tasks = 2;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete a list of tasks.
message DeleteTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// Response with multiple Tasks.
message MultiTaskResponse {
  clarifai.api.status.Status status = 1;
  repeated Task tasks = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Response with a single Task.
message SingleTaskResponse {
  clarifai.api.status.Status status = 1;
  Task task = 2;
}

// GetTaskCountRequest can be used for fetching -
// 1. Task annotation count per user, per status
// 1. Task input (anchor annotations) count per user, per status
message GetTaskCountRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;

  // task_id for which count per user per status is needed
  string task_id = 2;

  // for given task_id, user_ids to filter on (optional)
  repeated string user_ids= 3;
}



// SingleTaskCountResponse represent counts of annotations or inputs(anchor annotations) for labelers in given task
message SingleTaskCountResponse {
  clarifai.api.status.Status status = 1;
  string app_id = 2;
  string task_id = 3;
  repeated TaskStatusCountPerUser counts = 4;
}



////////////////////////////////////////////////////////////////////////////////
// Label Orders
////////////////////////////////////////////////////////////////////////////////

// Request to create label orders.
message PostLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated LabelOrder label_orders = 2;
}

// Request to get one label order.
message GetLabelOrderRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string label_order_id = 2;
}

// Request to list multiple label orders.
message ListLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Request to patch a list of label orders.
message PatchLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated LabelOrder label_orders = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete a list of label orders.
message DeleteLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// Response with multiple label order.
message MultiLabelOrderResponse {
  clarifai.api.status.Status status = 1;
  repeated LabelOrder label_orders = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Response with a label order.
message SingleLabelOrderResponse {
  clarifai.api.status.Status status = 1;
  LabelOrder label_order = 2;
}

// Request to create Collectors.
message PostCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collector collectors = 2;
}

// PatchCollectorsRequest
message PatchCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Collector collectors = 2;

  // The action to perform on the patched objects
  // Only 'overwrite' is supported
  string action = 3;
}

// Request to delete several things by the list of ids.
message DeleteCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// Request to GET a single Collector.
message GetCollectorRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  //The collecgtor id
  string collector_id = 2;
}

// Request to GET all the Collectors.
message ListCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Response with multiple Collectors.
message MultiCollectorResponse {
  clarifai.api.status.Status status = 1;
  repeated Collector collectors = 2;
}

// Response with a single Collector.
message SingleCollectorResponse {
  clarifai.api.status.Status status = 1;
  Collector collector = 2;
}

// PostStatValuesRequest
message PostStatValuesRequest {
  // The user and app information for the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The stats to post, can post more than one at a time.
  repeated StatValue stat_values = 2;
}

// MultiStatValueResponse
message MultiStatValueResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned stats values.
  repeated StatValue stat_values = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostStatValuesAggregateRequest
message PostStatValuesAggregateRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Query to retrieve aggregate values.
  repeated StatValueAggregateQuery stat_value_aggregate_queries = 2;
}

// MultiStatValueAggregateResponse
message MultiStatValueAggregateResponse {
  // The response status.
  clarifai.api.status.Status status = 1;

  // The aggregate results for each query passedin.
  repeated StatValueAggregateResult stat_value_aggregate_results = 2;
}











// PostTrendingMetricsViewRequest
message PostTrendingMetricsViewRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // For now view types 'apps', 'workflows', and 'models' are supported.
  string view_type = 2;
  // ID of the views object.
  string object_id = 3;
}

// ListTrendingMetricsViewsRequest
message ListTrendingMetricsViewsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // For now view types 'apps', 'workflows', and 'models' are supported.
  string view_type = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// MultiTrendingMetricsViewResponse
message MultiTrendingMetricsViewResponse {
  clarifai.api.status.Status status = 1;
  repeated TrendingMetric metrics = 2;
}













































// GetModuleRequest
message GetModuleRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  repeated string additional_fields = 3;
}

// ListModulesRequest
message ListModulesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  repeated string additional_fields = 5;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 6;
  oneof sort_by {
    // Whether to order by the created_at time.
    bool sort_by_created_at = 7;
    // Whether to order by the number of users stared the app
    bool sort_by_star_count = 8;
    // If neither sort option is set to true, will sort by modified_at.
    bool sort_by_modified_at = 9;
    // Whether to order by the external id
    bool sort_by_id = 11;
  }

  // Filtering options:
  bool starred_only = 4;
  // Filter modules by bookmark. If set, only return bookmarked modules. Otherwise none bookmarked modules only.
  bool bookmark = 10;

  // Searching options:
  // Specify a search parameter in order to perform keyword search on the
  // following fields of the module:
  //   - id
  //   - description
  //   - user_id (unless user_app_id.user_id is already set)
  //
  // Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  // and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  //
  // NOTE: Both the list of fields searched and the exact keyword matching
  // rules are subject to change and not guaranteed to be backwards-compatible.
  string search = 14;
  // Filter by the id and description of the module. This supports wildcard queries like "gen*" to match "general" as an example.
  // Deprecated: use search instead.
  string name = 12 [deprecated = true];
  // Filter by the application owner whose this module belongs to
  // Deprecated: use search instead of name.
  bool filter_by_user_id = 13 [deprecated = true];
}

// PostModulesRequest
message PostModulesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // This allows you to create one or more module by posting it to the API.
  repeated Module modules = 3;
}

// PatchModulesRequest
message PatchModulesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Module modules = 2;

  // The action to perform on the patched objects
  // Supported values: 'overwrite' and 'remove'.
  //
  // Note that 'remove' can only be used to remove the module image by setting
  // 'image.url' in the request to the current value returned for that module.
  string action = 3;
}

// Request to delete several things by the list of ids.
message DeleteModulesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// SingleModuleResponse
message SingleModuleResponse {
  clarifai.api.status.Status status = 1;
  Module module = 2;
}

// MultiModuleResponse
message MultiModuleResponse {
  clarifai.api.status.Status status = 1;
  repeated Module modules = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// request for different endpoints currently.
message GetModuleVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  string module_version_id = 3;
}

// ListModuleVersionsRequest
message ListModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// PostModuleVersionsRequest
message PostModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  // This allows you to create one or more module by posting it to the API.
  repeated ModuleVersion module_versions = 3;
}

// Request to delete several module versions by the list of ids.
message DeleteModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  repeated string ids = 3;
}

// SingleModuleVersionResponse
message SingleModuleVersionResponse {
  clarifai.api.status.Status status = 1;
  ModuleVersion module_version = 2;
}

// MultiModuleVersionResponse
message MultiModuleVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated ModuleVersion module_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}



// GetInstalledModuleVersionRequest
message GetInstalledModuleVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // the ID to get of the install module version.
  string installed_module_version_id = 2;
}

// ListInstalledModuleVersionsRequest
message ListInstalledModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostInstalledModuleVersionsRequest to install a module version into the app in the URL
message PostInstalledModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // This allows you to create one or more module by posting it to the API.
  repeated InstalledModuleVersion installed_module_versions = 2;
}

// PostInstalledModuleVersionsKeyRequest to associate a key of the caller's to the installed module
// version.
message PostInstalledModuleVersionsKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // the ID to get of the install module version.
  string installed_module_version_id = 2;
  // Note(zeiler): we don't provide a key to create since it's always deterministic.
  // we'll create a PAT, owned by the caller with the scopes that the module requests.
  // in the future if we want we can pass in a Key key = 3; field so that the caller
  // can adjust the scopes, but for now that doesn't seem necessary.
}

// Request to delete several installed module versions by the list of ids.
message DeleteInstalledModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// SingleInstalledModuleVersionResponse
message SingleInstalledModuleVersionResponse {
  clarifai.api.status.Status status = 1;
  InstalledModuleVersion installed_module_version = 2;
}

// MultiInstalledModuleVersionResponse
message MultiInstalledModuleVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated InstalledModuleVersion installed_module_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListNextTaskAssignmentsRequest
message ListNextTaskAssignmentsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
}

// Request to perform bulk operations on a list of inputs based on input source.
message PostBulkOperationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List of bulk operation(s) to be performed e.g bulk update metadata or tags or labels etc.
  repeated clarifai.api.BulkOperation bulk_operations = 2;
}

// Request to list all the bulk operations.
message ListBulkOperationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Request to get the details of a bulk operation by ID.
message GetBulkOperationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The bulk operation id
  string id = 2;
}

// Cancel a list of bulk operation ids
message CancelBulkOperationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List of bulk operation ids to be cancelled
  repeated string ids = 2;
}

// Request to delete the terminated bulk operations by ID
// Only operations in terminated state can be deleted.
message DeleteBulkOperationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List of bulk operation ids to be deleted
  repeated string ids = 2;
}

// SingleBulkOperationsResponse
message SingleBulkOperationsResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.BulkOperation bulk_operation = 2;
}

// MultiBulkOperationsResponse
message MultiBulkOperationsResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.BulkOperation bulk_operation = 2;
}





// PutTaskAssignmentsRequest
message PutTaskAssignmentsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
  string input_id = 3;
}






// List all the input ingestion jobs
message ListInputsAddJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message GetInputsAddJobRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of add inputs job
  string id = 2;
}

message CancelInputsAddJobRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of add inputs job to be cancelled
  string id = 2;
}

// MultiInputsAddJobResponse
message MultiInputsAddJobResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.InputsAddJob inputs_add_jobs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleInputsAddJobResponse
message SingleInputsAddJobResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.InputsAddJob inputs_add_job = 2;
}

// Start a multipart upload
message PostUploadsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated clarifai.api.Upload uploads = 2;
}

// Stops or deletes multipart upload
message DeleteUploadsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

message ListUploadsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message GetUploadRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Upload ID
  string upload_id = 2;
}

message SingleUploadResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.Upload upload = 2;
}

message MultiUploadResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.Upload uploads = 2;
}

// Upload a part of a multipart upload.
// Behaviour on completion depends on the endpoint that was used to initiate the upload.
message PutUploadContentPartsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string upload_id = 2;
  repeated UploadContentPart content_parts = 3;
}

// Initiates retrieval of inputs from cloud storage from a user provided data source.
// Will create and return an inputs-add-job for tracking progress.
// Archives will be extracted and their contents will be processed as inputs.
//
// The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
// files in the images_folder beginning with abc or in a subfolder beginning with abc.
// For example:
// bucket/images_folder/abcImage.png
// bucket/images_folder/abc-1/Data.zip
//
// If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
// Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
// in which case it only requires rights to access that particular file.
message PostInputsDataSourcesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated InputsDataSource data_sources = 2;

  // If call back url is set, we will send a Post request to this endpoint with job status.
  string call_back_url = 3;

  // Personal Access Token to the application to which inputs are added
  string app_pat = 4;
}

message GetInputsExtractionJobRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string inputs_extraction_job_id = 2;
}

message ListInputsExtractionJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message SingleInputsExtractionJobResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.InputsExtractionJob inputs_extraction_job = 2;
}

message MultiInputsExtractionJobResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.InputsExtractionJob inputs_extraction_jobs = 2;
}

// Cancel a list of extraction job ids
message CancelInputsExtractionJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List of extraction job ids to be cancelled
  repeated string ids = 2;
}

// Start uploading a file archive containing inputs.
// Will create and return an inputs-add-job for tracking progress.
//
// Associated inputs-add-job contains an upload id which should be completed through `PutUploadContentParts` endpoint.
// Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
message PostInputsUploadsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated clarifai.api.InputsUpload inputs_uploads = 2;
}

// GetRunnerRequest
message GetRunnerRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string runner_id = 2;
}

// ListRunnersRequest
message ListRunnersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostRunnersRequest
message PostRunnersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // This allows you to create one or more runner by posting it to the API.
  repeated Runner runners = 3;
}

// Request to delete several things by the list of ids.
message DeleteRunnersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}



// SingleRunnerResponse
message SingleRunnerResponse {
  clarifai.api.status.Status status = 1;
  Runner runner = 2;
}

// MultiRunnerResponse
message MultiRunnerResponse {
  clarifai.api.status.Status status = 1;
  repeated Runner runners = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}





message ListRunnerItemsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string runner_id = 2;
}

// PostRunnerItemOutputsRequest
message PostRunnerItemOutputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string runner_id = 2;
  string item_id = 3;
  // This allows you to create one or more runner by posting it to the API.
  repeated RunnerItemOutput runner_item_outputs = 4;
}





// MultiRunnerItemResponse
message MultiRunnerItemResponse {
  clarifai.api.status.Status status = 1;
  repeated RunnerItem items = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message RunnerItem {
  // A UUID hash for this work item.
  string id = 1;

  // A description of the work to be done in case needed for UIs.
  string description = 2;

  // TODO(zeiler): make these options a oneof.
  // first work to do would be an inference runner.
  PostModelOutputsRequest post_model_outputs_request = 3;
  // training request next.
}



message RunnerItemOutput {
  // The output of the first task type.
  // TODO(zeiler): should the interface be more like pairs of things wiht request/response in one "item"?
  MultiOutputResponse multi_output_response = 1;

  // training response ??? or is it a model upload.
  // again knowing what to send back from an implementation is goin gto be confusing unless we pair
  // up the request and response.
}



message MultiRunnerItemOutputResponse {
  clarifai.api.status.Status status = 1;
  repeated RunnerItemOutput runner_item_outputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Get the estimated training time for a model version
message PostModelVersionsTrainingTimeEstimateRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersion model_versions = 3;
  uint64 estimated_input_count = 4;
}

// Estimated training time in seconds
message MultiTrainingTimeEstimateResponse {
  clarifai.api.status.Status status = 1;
  repeated google.protobuf.Duration training_time_estimates = 2;
}